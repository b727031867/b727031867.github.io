<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一叶知秋</title>
  
  <subtitle>大道至简，知易行难，知行合一，得到功成</subtitle>
  <link href="https://b727031867.github.io/atom.xml" rel="self"/>
  
  <link href="https://b727031867.github.io/"/>
  <updated>2020-10-10T14:16:12.833Z</updated>
  <id>https://b727031867.github.io/</id>
  
  <author>
    <name>Mr.G</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://b727031867.github.io/2020/10/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    <id>https://b727031867.github.io/2020/10/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/</id>
    <published>2020-10-10T12:12:44.000Z</published>
    <updated>2020-10-10T14:16:12.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式学习笔记"><a href="#设计模式学习笔记" class="headerlink" title="设计模式学习笔记"></a>设计模式学习笔记</h1><ul><li><h2 id="七大设计原则"><a href="#七大设计原则" class="headerlink" title="七大设计原则"></a>七大设计原则</h2></li></ul><ol><li><h3 id="单一职责原则：一个类只负责一项职责"><a href="#单一职责原则：一个类只负责一项职责" class="headerlink" title="单一职责原则：一个类只负责一项职责"></a>单一职责原则：一个类只负责一项职责</h3><p>作用：防止修改代码时，影响其他功能，降低类之间的耦合</p><p>注意：逻辑简单，可以违背类级别的单一职责，即一个类包含多个功能，但是，最低要保证方法的职责单一</p></li><li><h3 id="接口隔离原则：类只依赖所需的最小接口"><a href="#接口隔离原则：类只依赖所需的最小接口" class="headerlink" title="接口隔离原则：类只依赖所需的最小接口"></a>接口隔离原则：类只依赖所需的最小接口</h3><p>作用：避免实现自身用不到的方法、降低耦合，提高代码阅读性</p><p>特点：把通用的方法抽取到更小的接口中，类实现多个小接口来满足自身的需要</p></li><li><h3 id="依赖倒置（倒转）原则：抽象不依赖细节，细节依赖抽象"><a href="#依赖倒置（倒转）原则：抽象不依赖细节，细节依赖抽象" class="headerlink" title="依赖倒置（倒转）原则：抽象不依赖细节，细节依赖抽象"></a>依赖倒置（倒转）原则：抽象不依赖细节，细节依赖抽象</h3><p>作用：让代码更加稳定，减少修改的可能性（抽象层较为稳定）；通过接口与抽象类编写规范，交给实现类完成功能。</p><p>特点：面向接口编程，通过传递接口参数，根据具体实现类的不同而完成不同的功能。相当于通过接口进行耦合，避免了类与类之间的强耦合。</p></li><li><h3 id="里氏替换原则：能用父类的位置都能用子类替换"><a href="#里氏替换原则：能用父类的位置都能用子类替换" class="headerlink" title="里氏替换原则：能用父类的位置都能用子类替换"></a>里氏替换原则：能用父类的位置都能用子类替换</h3><p>作用：减少继承的使用，通过聚合、组合、依赖三种类的关系来取代继承；防止子类无意中重写父类方法，而导致程序出错（如果子类重写了父类方法，将调用子类的实现方法，可能导致与原来不同的结果）</p><p>特点：子类尽量不重写父类方法，运用父类的位置可以替换成子类。</p></li><li><h3 id="开闭原则：对扩展开放，对修改关闭"><a href="#开闭原则：对扩展开放，对修改关闭" class="headerlink" title="开闭原则：对扩展开放，对修改关闭"></a>开闭原则：对扩展开放，对修改关闭</h3><p>作用：能够避免修改代码，灵活扩充功能（是使用设计模式的最终目标，上述原则作为此原则的铺垫）</p><p>特点：使用（调用）方无需修改代码，提供方可以通过添加抽象方法直接添加功能（由子类实现功能）</p></li><li><h3 id="迪米特原则（最小知道原则）：类对依赖的类知道的越少越好"><a href="#迪米特原则（最小知道原则）：类对依赖的类知道的越少越好" class="headerlink" title="迪米特原则（最小知道原则）：类对依赖的类知道的越少越好"></a>迪米特原则（最小知道原则）：类对依赖的类知道的越少越好</h3><p>作用：降低类之间的耦合</p><p>特点：只和直接关联的类通信，类自身的逻辑应该由自身内部完成，对外只提供公开方法</p><p>直接关联的类：成员方法、方法参数、返回值用到的类（<strong>局部变量使用的类<em>不属于</em></strong>）</p></li><li><h3 id="合成复用原则：少用继承，多用组合、聚合代替继承"><a href="#合成复用原则：少用继承，多用组合、聚合代替继承" class="headerlink" title="合成复用原则：少用继承，多用组合、聚合代替继承"></a>合成复用原则：少用继承，多用组合、聚合代替继承</h3><p>特点：通过少用继承，多用依赖的方式降低类之间的耦合度</p></li></ol><ul><li><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><ul><li>作用：统一建模语言，用于描述软件模型中各个元素之间的关系</li><li>分类<ul><li>动态图：<ol><li>序列图</li><li>协作图</li><li>状态图</li><li>活动图</li></ol></li><li>静态图：<ol><li>用例图</li><li>类图</li><li>对象图</li><li>包图</li><li>构件图</li><li>部署图</li></ol></li></ul></li></ul></li></ul><ul><li><h2 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h2><ol><li><p>依赖关系：类中使用了其他类（范围最大），则它们存在依赖关系</p><p><img src="/assets/image-20200619141549656.png" alt="image-20200619141549656"></p></li><li><p>关联关系：具有方向性，用于表示对象间的数量关系（1：1、1：n、n：n）</p><p><img src="/assets/image-20200619141508154.png" alt="image-20200619141508154"></p></li><li><p>聚合关系：整体与部分<strong>可以分割</strong>（例如：你与你的电脑，电脑可有可无）</p><p><img src="/assets/image-20200619141441647.png" alt="image-20200619141441647"></p></li><li><p>组合关系：整体与部分<strong>不可分割</strong>——同生共死（比如脸上含有眼睛、嘴巴等）</p><p><img src="/assets/image-20200619141447983.png" alt="image-20200619141447983"></p></li><li><p>泛化关系：依赖关系的特例，表示继承关系</p><p><img src="/assets/image-20200619141602834.png" alt="image-20200619141602834"></p></li><li><p>实现关系：依赖关系的特例，表示它与它实现接口的关系</p><p><img src="/assets/image-20200619141615840.png" alt="image-20200619141615840"></p></li></ol></li></ul><h2 id="23种设计模式"><a href="#23种设计模式" class="headerlink" title="23种设计模式"></a>23种设计模式</h2><p><img src="/assets/image-20200619143149221.png" alt="image-20200619143149221"></p><ol><li><h3 id="创建型：用于对象创建管理"><a href="#创建型：用于对象创建管理" class="headerlink" title="创建型：用于对象创建管理"></a>创建型：用于对象创建管理</h3><ul><li><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>作用：确保重量级对象只返回一个实例，避免资源浪费、并发问题；对于频繁创建与销毁对象的情况，可以提高性能</p><p><strong>常见写法：</strong></p><ol><li><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><ul><li><p>静态常量饿汉式实现：</p><ol><li><p>优点：实现简洁，通过类装载机制保证线程安全</p></li><li><p>缺点：无法懒加载，可能浪费内存</p></li><li><p>实现步骤：</p><ul><li><p>构造方法私有</p><p><img src="/assets/image-20200619183637492.png" alt="image-20200619183637492"></p></li><li><p>静态成员变量new自身（无法懒加载）</p><p><img src="/assets/image-20200619183620617.png" alt="image-20200619183620617"></p></li><li><p>提供公有静态方法获取成员实例</p></li></ul></li></ol><p><img src="/assets/image-20200619183711499.png" alt="image-20200619183711499"></p></li><li><p>静态代码块饿汉式实现</p><p>只是把上述new的过程放入静态代码块实现，优缺点、步骤同上</p><p><img src="/assets/image-20200619191803962.png" alt="image-20200619191803962"></p></li></ul></li><li><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><ul><li><p>线程不安全懒汉式实现</p><ol><li><p>优点：懒加载</p></li><li><p>缺点：线程不安全（不建议使用）</p></li><li><p>实现步骤</p><ul><li><p>构造器私有</p><p><img src="/assets/image-20200619192025316.png" alt="image-20200619192025316"></p></li><li><p>定义静态实例变量</p><p><img src="/assets/image-20200619192033415.png" alt="image-20200619192033415"></p></li><li><p>在返回实例方法中初始化静态实例变量</p><p><img src="/assets/image-20200619192042676.png" alt="image-20200619192042676"></p></li></ul></li></ol></li><li><p>线程安全（同步方法）懒汉式实现</p><ol><li><p>优点：线程安全</p></li><li><p>缺点：同步整个方法的性能不高（每次返回实例都需要同步）</p></li><li><p>实现步骤：根据上述步骤，在返回实例的方法上添加同步关键字</p><p><img src="/assets/image-20200619193647024.png" alt="image-20200619193647024"></p></li></ol></li><li><p>同步代码块懒汉式实现</p><ol><li><p>优点：效率比同步方法高</p></li><li><p>缺点：<strong>线程不安全</strong>（不能使用）</p></li><li><p>实现步骤：根据上述步骤，改为同步代码块实现返回实例的方法</p><p><img src="/assets/image-20200619193914779.png" alt="image-20200619193914779"></p></li></ol></li></ul></li><li><h4 id="双重校验实现"><a href="#双重校验实现" class="headerlink" title="双重校验实现"></a>双重校验实现</h4><ol><li><p>优点：懒加载、线程安全、性能高</p></li><li><p>缺点：<strong>JDK5之前</strong>的内存模型存在缺陷，无法使用volatile关键字完全避免指令重排序</p></li><li><p>实现步骤</p><ul><li><p>构造器私有，同上</p></li><li><p>声明静态成员变量，并且添加<strong>volatile</strong>关键字修饰</p><p><img src="/assets/image-20200619195741899.png" alt="image-20200619195741899"></p></li><li><p>获取实例的方法进行双重检查</p><p><img src="/assets/image-20200619195818520.png" alt="image-20200619195818520"></p></li></ul></li></ol></li><li><h4 id="静态内部类实现"><a href="#静态内部类实现" class="headerlink" title="静态内部类实现"></a>静态内部类实现</h4><ol><li><p>优点：线程安全、懒加载（通过JVM静态内部类装载机制保证线程安全与懒加载）</p></li><li><p>缺点：无法防止反序列化创建对象</p></li><li><p>实现步骤</p><ul><li><p>构造器私有，同上</p></li><li><p>写一个静态内部类，定义并且初始化实例变量</p><p><img src="/assets/image-20200619200843174.png" alt="image-20200619200843174"></p></li><li><p>调用静态内部类的实例变量获取实例</p><p><img src="/assets/image-20200619201012758.png"></p></li></ul></li></ol></li><li><h4 id="枚举实现"><a href="#枚举实现" class="headerlink" title="枚举实现"></a>枚举实现</h4><ol><li><p>优点：线程安全、防止反序列化创建对象、实现简单</p></li><li><p>缺点：不能懒加载</p></li><li><p>实现步骤</p><ul><li><p>定义枚举</p><p><img src="/assets/image-20200619201510225.png" alt="image-20200619201510225"></p></li><li><p>添加单例属性与自己的方法</p><p><img src="/assets/image-20200619202324162.png" alt="image-20200619202324162"></p></li></ul></li></ol></li></ol></li><li><h4 id="简单（静态）工厂模式"><a href="#简单（静态）工厂模式" class="headerlink" title="简单（静态）工厂模式"></a>简单（静态）工厂模式</h4><ol><li><p>优点：实现创建对象和使用分离（与客户端解耦）</p></li><li><p>缺点：</p><ol><li>工厂类违反单一职责，负担过重</li><li>违反开闭原则，扩展复杂，需要修改代码</li></ol></li><li><p>作用：封装创建多种对象、某一类对象的行为，避免添加新的产品类型而改动大量代码</p></li><li><p>类图：简单工厂持有抽象产品的引用，根据传入的产品类型选择实例化对象。</p><p><img src="/assets/image-20200625124752962.png" alt="image-20200625124752962"></p></li><li><p>其他：不推荐使用，除非产品与工厂都十分简单</p></li></ol><p><strong>常见写法：</strong></p><ol><li>定义各类产品的抽象类</li><li>定义具体的产品类，并且继承其抽象类</li><li>定义工厂类</li><li>在构造方法中传入具体产品类型</li><li>根据产品类型new实例对象并且返回其抽象类型</li><li>需要生产产品的类中，通过聚合或者组合引用工厂对象，调用创建方法创建产品</li></ol></li><li><h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><ol><li><p>优点：</p><ol><li>能对客户端隐藏实现细节（最小知道（迪米特）原则）</li><li>允许抽象工厂通过多态（继承）灵活创建不同的对象，每种具体工厂负责单一产品（单一职责原则）</li><li>添加工厂与产品无需修改客户端、无需修改其他具体工厂和具体产品（开闭原则）</li></ol></li><li><p>缺点：</p><ol><li>抽象度高，理解与使用较难</li><li>类的数量很多，导致系统复杂，并且需要额外开销</li></ol></li><li><p>作用：解决多种工厂导致类数量过多、将实例化的过程推迟到子类中，符合开闭原则。</p></li><li><p>类图：产品与工厂都是抽象类，它们都能扩展自己的子类。工厂依赖抽象产品；具体的工厂实现生产具体产品的方法，并且它依赖于具体的产品</p><p><img src="/assets/image-20200620121517991.png" alt="image-20200620121517991"></p></li><li><p>其他：多种工厂对应多种产品的情况常见于针对特定类型的产品，添加特定的生产工厂。例如生产中国菜和日本菜，材料不同，菜式不同、厨房也不同，但是厨房生产菜的抽象是不变的，因此需要生产额外地区的菜，只需要添加新的菜式和厨房即可。比如新添加泰国菜和泰国厨房。<strong>如果结合简单工厂可以让中国厨房生产粤菜、湘菜，实现一个具体的工厂生产多种具体的产品，但是这样就违背了开闭原则，可以通过抽象工厂实现而不违背开闭原则。</strong></p></li></ol><p><strong>常见写法：</strong></p><ol><li>创建抽象工厂类，定义工厂的生产方法</li><li>创建抽象产品类，定义抽象产品方法</li><li>创建具体产品类，继承抽象产品类，实现产品的抽象方法</li><li>创建具体工厂类，继承抽象工厂类，实现生产的抽象方法</li><li>调用方通过调用具体工厂类，产生不同的具体产品</li></ol></li><li><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><ol><li><p>优点：</p><ol><li>对客户端隔离了类的生成（最小知道（迪米特）原则）</li><li>增加产品族（某种品牌的工厂）时，符合开闭原则</li><li>对需要使用同一产品族（同一个品牌）的情况有利（例如：组装电脑的所有配件都选用英特尔，而不是CPU选英特尔，显卡选英伟达）</li></ol></li><li><p>缺点：由于开闭原则具有倾斜性（会让某一方更加容易开闭），增加新的产品等级（新产品），会导致所有具体工厂都需要添加新产品的生产方法，违背了开闭原则</p></li><li><p>作用：用于产品等级结构稳定，产品族变动的情况。（生产产品的种类固定，但是品牌不同）</p></li><li><p>类图：</p><p><img src="/assets/0_PFFZ4GGOKTH_OP6TAY%7DQE.png" alt="img"></p></li><li><p>其他：抽象工厂最好用于产品种类固定的情况</p></li></ol></li><li><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><ol><li><p>优点：简化创建过程（避免反复Get与Set被复制对象的值）</p></li><li><p>缺点：通过重写克隆方法实现原型模式，不符合开闭原则</p></li><li><p>作用：灵活的克隆简单对象</p></li><li><p>类图：</p><p><img src="/assets/image-20200628221245858.png" alt="image-20200628221245858"></p></li><li><p>实现方法：</p><ol><li>自己定义一个抽象原型类，包含一个抽象的克隆方法，需要克隆的类继承该类并且实现克隆方法。在方法中创建一个新对象，并且把属性值都重新赋值到新对象上，最后返回新对象</li><li>通过实现Cloneable接口并且重写Object类中的clone方法。在方法中调用super.clone()，最终强转回具体的对象返回</li></ol></li></ol><ul><li><p><strong>浅拷贝</strong></p><ol><li>特点：复制基础类型的值，无法复制引用对象，引用对象只复制引用值（指针）</li><li>实现方法：同上</li></ol></li><li><p><strong>深拷贝</strong></p><ol><li><p>特点：复制所有属性，包含引用对象</p></li><li><p>实现方法：</p><ol><li><p>上述使用super.clone()方法只能浅拷贝，需要自己手动复制引用对象，通过引用对象也实现clone方法，调用引用对象的clone方法，返回引用对象，再赋值到当前要深拷贝的对象中，最后返回深拷贝对象</p></li><li><p>使用序列化。首先，<strong>对象必须实现Serializable接口</strong>，然后通过序列化与反序列化进行深拷贝</p><p><img src="/assets/image-20200629111247527.png" alt="image-20200629111247527"></p></li></ol></li></ol></li><li><p><strong>原型管理器</strong>：将多种原型（需要克隆的）对象用哈希表进行管理，相当于克隆对象的工厂，便于扩展原型对象，类图如下：</p><p><img src="/assets/image-20200629112749121.png" alt="image-20200629112749121"></p></li></ul></li><li><h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><ol><li><p>优点：</p><ol><li>分离复杂对象的创建流程，让对象与对象的创建过程解耦</li><li>能用相同的创建流程创建不同的对象，精细的控制创建复杂对象的过程</li><li>通过抽象建造者充当缓冲层，具体建造者之间相互隔离，便于替换或添加新的具体建造者，符合开闭原则</li></ol></li><li><p>缺点：</p><ol><li>对于产品之间差异过大的情况，不适合使用，适用范围受限</li><li>对于产品内部复杂、细微差异过多的情况，会导致具体建造者过多，不利于维护与阅读</li></ol></li><li><p>作用：将复杂对象与它的构建分离，让同样的构建过程创建不同的对象</p></li><li><p>类图：</p><ul><li><p>抽象建造者（Builder）：负责规定返回产品的方法、创建产品部件包含的方法</p></li><li><p>具体建造者（ConcreteBuilder）：实现创建产品部件的方法，定义部件的装配过程，可有选择的重写返回产品的方法</p></li><li><p>产品（Product）：被构建的复杂对象，包含多个部件。</p></li><li><p>指挥者（Director）：在construct方法中定义不同部件（属性）的建造次序（例如盖房子，顺序为先打地基，再砌墙，最后盖屋顶），可以定义多个construct来控制组件的建造顺序（变为先砌墙，再打地基，最后盖屋顶），最后返回构建完毕的产品。如果对象组装简单，可以省略指挥者类，将构造方法置于抽象建造者中；如果对象组装复杂，可以用钩子函数决定是否组装某些组件（类似于模板方法模式）</p><p><img src="/assets/image-20200629172125977.png" alt="image-20200629172125977"></p></li></ul></li><li><p>使用场景：</p><ol><li>产品之间相似度高（例如配件相似、组装流程相似）</li><li>产品的创建十分复杂，需要自由控制创建流程</li><li>希望产品的创建过程独立于创建该对象的类、用相同的创建过程创建不同的产品</li></ol></li><li><p>实现方法：</p><ol><li>编写产品类，确定产品具有哪些组件（属性）</li><li>编写抽象建造者，初始化一个产品对象成员变量，定义产品相似的部分、定义返回产品的方法</li><li>编写具体建造者，创建并且设置产品成员变量的属性（例如：产品成员变量是车，包含发动机、轮胎，此处确定产品具体的部分使用什么组件，使用大马力发动机与防滑轮胎）、实现返回产品（可选）</li><li>编写指挥者类，通过construct方法，根据不同的具体建造者，确定产品的装配流程（确定是先组装轮胎还是先组装发动机），返回产品</li><li>编写客户端，定义具体的建造者与指挥者，传入具体建造者的类型给指挥者，然后调用指挥者的construct方法生产产品</li></ol></li></ol></li></ul></li><li><h3 id="结构型：让类或对象之间组织成更加灵活、强大的结构"><a href="#结构型：让类或对象之间组织成更加灵活、强大的结构" class="headerlink" title="结构型：让类或对象之间组织成更加灵活、强大的结构"></a>结构型：让类或对象之间组织成更加灵活、强大的结构</h3><ul><li><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><h4 id="名词解释：目标类——客户端需要用的接口或方法（想要通过调用已有接口或方法来实现的接口或者方法）、适配者——被适配的类（已完成的接口或方法）"><a href="#名词解释：目标类——客户端需要用的接口或方法（想要通过调用已有接口或方法来实现的接口或者方法）、适配者——被适配的类（已完成的接口或方法）" class="headerlink" title="名词解释：目标类——客户端需要用的接口或方法（想要通过调用已有接口或方法来实现的接口或者方法）、适配者——被适配的类（已完成的接口或方法）"></a>名词解释：目标类——客户端需要用的接口或方法（想要通过调用已有接口或方法来实现的接口或者方法）、适配者——被适配的类（已完成的接口或方法）</h4><ol><li><p>优点：</p><ol><li>通过适配与兼容来重用某些已有的接口，提高了代码的复用性</li><li>将目标类与适配者分离，降低了代码耦合热望</li><li>添加适配器类时，符合开闭原则</li><li>对于对象适配器，可以适配多个适配者（持有多个适配者的成员变量）；根据里氏替换原则，可以适配适配者（被适配的类）的子类</li></ol></li><li><p>缺点：</p><ol><li>适配者类不能为final类</li><li>对于类适配器，Java等单继承的语言，<ol><li>一次只能适配一个适配者</li><li>目标类只能为接口，有一定的局限性</li></ol></li><li>对于对象适配器，修改适配者的方法复杂（可以通过实现一个适配者的子类，修改方法后，替换适配器中持有的成员变量为该子类对象）</li></ol></li><li><p>作用：通过适配器来兼容不同的接口，使得它们能协同工作</p></li><li><p>适配器分类</p><ol><li><p>类适配器：继承适配者，实现目标类中需要的方法或者接口</p><p><img src="/assets/image-20200701221920901.png" alt="image-20200701221920901"></p></li><li><p>对象适配器：依赖适配者（适配器类中持有适配者成员变量），继承或者实现目标类</p><p><img src="/assets/image-20200701222101467.png" alt="image-20200701222101467"></p></li><li><p>单接口（缺省）适配器：通过抽象类<strong>空（默认）实现</strong>接口中的方法，子类可以<strong>有选择的</strong>重写这些空方法</p><p><img src="/assets/image-20200701223134101.png" alt="image-20200701223134101"></p></li><li><p>双向适配器：在对象适配器中，持有目标类与适配者的成员变量</p><p><img src="/assets/image-20200701224613210.png" alt="image-20200701224613210"></p></li></ol></li><li><p>使用场景：</p><ol><li>已有的接口和想要的新接口功能几乎相同，只是规格不同（比如换算单位不一样，电压标准不同等等）</li><li>创建可重复使用的类，这个类作为那些没有太大关联的类（包括以后要添加的类）的桥梁</li></ol></li></ol></li><li><h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><ol><li><p>优点：</p><ol><li>分离抽象接口与实现部分。通过关联关系代替继承关系，让抽象和实现能够根据各自的维度独立变化，由不同维度组合出不同功能的对象</li><li>减少了继承层级，减少了子类数量</li><li>扩展不同维度中独立变化的部分，只需要添加对应维度的子类即可，符合开闭原则</li></ol></li><li><p>缺点：</p><ol><li>正确的识别类的不同维度的变化比较困难，需要十分有经验</li><li>需要在设计阶段就进行抽象分析，增加了系统的设计与理解难度</li></ol></li><li><p>作用：将抽象部分与它的实现部分解耦，让两者能够独立变化</p></li><li><p>类图：</p><p><img src="/assets/image-20200710072024115.png" alt="image-20200710072024115"></p></li><li><p>使用场景：</p><ol><li>避免不同维度的变化通过静态的继承关系实现，想要在抽象层建立中关联关系</li><li>系统希望对抽象角色与具体角色动态耦合（即将抽象对象的子类与实现对象的子类通过关联关系进行动态组合）</li><li>一个类存在多种独立变化的维度，并且每种维度都希望能够独立扩展</li><li>对于使用多层继承会造成类数量的过多的系统</li></ol></li><li><p>编写步骤：</p><ol><li>编写抽象类，通过构造方法注入具体实现接口的成员变量，并且在抽象类中定义抽象方法</li><li>编写具体实现接口，定义（需要独立变化与扩展的）业务方法</li><li>编写具体实现接口的实现类，实现上述的业务方法</li><li>编写细化（扩展）抽象子类，实现抽象类中定义的抽象方法。此时，可以调用父类中具体实现接口的成员变量中的方法，完成对不同维度功能的组合</li><li>编写客户端，定义抽象引用和具体实现接口引用，创建不同的抽象细化类与具体接口实现类，将具体接口实现类Set到抽象细化类中，便可以组合出具有不同功能的对象</li></ol></li></ol></li><li><h4 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h4><ol><li><p>优点：</p><ol><li>扩展对象的功能比继承更加灵活，减少了继承层次，不会导致类爆炸</li><li>能够动态扩展对象的功能，实现不同行为（例如：读取配置文件，选择不同的具体装饰类）</li><li>对透明装饰模式，可以多次装饰某个对象，排列组合得到不同行为与功能的对象</li><li>具体组件类与具体装饰类互相独立，符合开闭原则</li></ol></li><li><p>缺点：</p><ol><li>因为不同的修饰方式可以产生功能不同的对象，所以会导致系统存在很多小对象，它们的区别仅仅是组合、连接的方式不同，不是类或者属性的不同，小对象过多会影响系统性能</li><li>对于被多次装饰的对象，不利于排查错误</li></ol></li><li><p>作用：动态的给某个对象添加额外的职责，提供比继承更加灵活的扩展方式</p></li><li><p>分类：</p><ol><li>透明装饰模式：<ol><li>客户端全部使用抽象组件接收实例化的部分</li><li>可以对组件多次装饰（因为都是抽象组件的子类，并且通过构造方法实例化抽象组件成员变量）</li><li>客户端没办法调用具体装饰器中新增的方法（因为抽象组件中没有定义这些方法）</li></ol></li><li>半透明装饰模式：<ol><li>客户端可以使用抽象组件接收具体组件，但是只能用具体装饰器引用接收具体装饰器的实例，从而能够调用具体装饰器中的新增方法</li><li>不能多次装饰具体组件，只能装饰一次</li></ol></li></ol></li><li><p>类图：图中为透明装饰模式，若为半透明装饰模式，则具体组件只能被装饰一次，并且可以单独调用被添加（用于装饰对象）的方法</p><p><img src="/assets/image-20200708221913631.png" alt="image-20200708221913631"></p></li><li><p>使用场景：</p><ol><li>不影响其他对象实例，只想对某个对象实例动态、透明的添加职责</li><li>无法使用继承或继承不利于系统维护与扩展时，可以通过装饰模式来扩展功能（例如：Java中的final类、继承层次过多等）</li></ol></li><li><p>编写方法：</p><ol><li>编写抽象组件类，定义抽象方法（需要被修饰、增强的方法）</li><li>编写具体组件类，继承抽象组件类</li><li>编写装饰类，继承抽象组件类，在类中添加抽象组件的成员变量，通过构造器实例化抽象组件的成员变量</li><li>在装饰类中，重写抽象方法时，调用成员变量的抽象方法</li><li>编写具体装饰类，继承装饰类，构造方法调用中调用装饰类的构造方法，传入抽象组件对象</li><li>在具体装饰类中，重写抽象方法时，<strong>调用成员变量的抽象方法（原本的业务方法），调用自身新增的业务方法</strong></li><li>编写客户端类，创建具体组件对象，传入具体装饰对象的构造方法中，<ol><li>若为透明装饰模式，则可以都用抽象组件引用接收对象并使用，并且可以多次装饰，没有办法调用被装饰后新增的业务方法</li><li>若为半透明装饰模式，则定义具体组件可以用抽象组件的引用接收，被装饰的对象只能用具体装饰器接收，此时可以调用具体装饰对象的新增业务方法</li></ol></li></ol></li></ol></li><li><h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><ol><li><p>优点：</p><ol><li>能够清楚地定义层次关系，客户端可以忽略层次的不同进行操作</li><li>透明组合模式下，由于客户端能够一致的使用叶子构件和容器构件的方法，所以能简化调用代码</li><li>添加叶子构件或者容器构件都十分方便，无需改动现有代码，符合开闭原则</li><li>不仅对树形结构的控制简单，而且能够通过叶子构件与容器构件递归组合，实现复杂的树形结构</li></ol></li><li><p>缺点：</p><ol><li>添加新的构件类型，容易产生过多的类</li><li>如果希望某个容器下只允许某种叶子构件，需要编写代码约束，十分复杂（不然客户端给A容器添加C容器的C叶子节点，而本来A容器应该添加A叶子节点）</li></ol></li><li><p>作用：组合多种对象，形成树形结构，表示部分-整体的层次结构。组合模式能统一操作叶子节点与父节点，无需关心它们的区别</p></li><li><p>分类：</p><ol><li>透明组合模式：调用叶子构件与容器构件都一样，但是调用叶子构件会产生异常，没有进行处理会出错</li><li>安全组合模式：抽象构件中不提供操作子节点的方式，这样客户端无法统一对叶子构件和容器构件编程，不会出现抛不支持操作异常的情况</li></ol></li><li><p>类图：</p><ul><li>AbstracComponent：抽象构件，可以是抽象类或者接口，为叶子节点（叶子构件）与父节点（容器构件）声明通用操作的接口</li><li>Composite：容器构件，实现抽象构件中的接口，使用集合存储它所管理的叶子节点列表，并且可以递归调用子节点的方法，直到调用时遇到叶子节点为止</li><li>Leaf：叶子构件，它没有子节点，实现抽象构件中的部分接口，如果调用了它未实现的操作方法，则可以抛出异常（例如：调用叶子节点增加子节点的方法，可以抛出不支持该操作的异常）</li></ul><p><img src="/assets/image-20200711220850156.png" alt="image-20200711220850156"></p></li><li><p>使用场景：</p><ol><li>具有部分与整体的层次结构，并且希望客户端统一管理部分与整体</li><li>希望在面向对象语言中处理树形结构，并且节点具有相似的方法</li><li>系统可以分离出叶子构件与容器构件，并且它们的类型数量不确定，希望随时扩充新类型(Swing包中的Panel(容器)和Button(叶子)等GUI编程)</li></ol></li><li><p>编写方法：</p><ol><li>编写抽象构件类：定义通用的子节点管理抽象方法(增删改查子节点)，定义需要实现的抽象业务方法</li><li>编写容器构件类：继承或者实现抽象构件中的方法，编写一个抽象构件集合，用于存储当前容器所管理的子构件列表</li><li>编写叶子构件类：继承或实现抽象构件中的方法</li><li>编写客户端，定义抽象构件的引用，实例化容器构件与叶子构件，将叶子构件添加到容器构件中，再调用容器构件的业务方法</li></ol></li></ol></li><li><h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><ol><li><p>优点：</p><ol><li>子系统内部的变化不影响外观对象</li><li>客户端只需要依赖外观对象，不需要关联子系统的各种对象，降低了耦合，让子系统更加容易使用</li><li>子系统内部的变化不影响客户端对其使用</li></ol></li><li><p>缺点：</p><ol><li>客户端可能绕过门面类直接访问子系统，想要避免这种情况会减低子系统的灵活性与可变性</li><li>如果门面类设计有缺陷，后期新增子系统或者新增门面功能会导致门面类代码变动，不符合开闭原则</li></ol></li><li><p>作用：作为子系统接口调用的统一入口，方便使用子系统</p></li><li><p>类图：</p><p><img src="/assets/image-20200714075134290.png" alt="image-20200714075134290"></p></li><li><p>使用场景：</p><ol><li>为客户端提供多种复杂子系统的统一API调用入口</li><li>客户端与子系统的耦合很强，通过引入外观类进行解耦</li><li>在多层结构中，通过外观类定义每层的入口，由外观类进行层与层之间的通信，降低了层之间的耦合度</li></ol></li><li><p>编写方法：</p><ol><li>编写抽象外观类，定义通用的抽象方法</li><li>编写子系统类（单例类、工厂类等），实现该子系统负责模块的方法</li><li>编写具体外观类继承抽象外观类，定义具体外观类中需要用到的子系统成员变量，调用并且组合子系统中的模块方法实现父类的抽象方法</li><li>创建客户端类，定义抽象门面类的引用，实例化具体门面类，调用通用的抽象方法</li></ol></li></ol></li><li><h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><ol><li><p>优点：</p><ol><li>重复利用（相同或相似的）细粒度对象，节省系统资源</li><li>区分了对象的外部状态与内部状态，它们相互独立，使得具有不同外部状态的对象可以共享相同的内部状态对象（例如：棋子的位置对象[外部状态]与黑色或白色棋子对象[内部状态]，可以通过设置不同的位置坐标，传入黑棋或者白棋，黑棋或白棋对象则只会产生一个）</li></ol></li><li><p>缺点：</p><ol><li>分离了内部状态与外部状态，使得对象变得复杂，对对象的操作也会复杂</li><li>由于分离了内部与外部状态，那么读取这个对象对应的外部状态需要耗费更长的时间</li></ol></li><li><p>作用：运用共享技术复用大量细粒度的对象</p></li><li><p>类图：使用单例模式创建共享的享元对象以及享元工厂；使用组合模式组合共享的享元对象与不共享的享元对象；使用享元模式对共享的对象进行缓存，而不是重复创建（此图为复合享元模式的类图）</p><p><img src="/assets/image-20200719122349688.png" alt="image-20200719122349688"></p></li><li><p>分类</p><ol><li>单纯享元模式：只存在可以共享的享元类，没有不可共享的享元类，即只有上图的ConcreteFlyweight类、AbstractFlyweight类、FlyweightFactory类</li><li>复合享元模式：使用组合模式组合了不可共享的类</li></ol></li><li><p>使用场景：</p><ol><li>系统中存在大量相同或者相似的对象</li><li>某种对象的大部分状态可以分为不变与变化的，将变化的状态封装成不共享的对象，不变的状态进行缓存</li><li>由于使用缓存池缓存享元对象，会耗费系统资源，所以享元对象应该被频繁使用，避免浪费资源</li></ol></li></ol></li><li><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><ol><li><p>优点：</p><ol><li>通过代理对象协调调用者与被调用者，降低了它们之间的耦合度</li><li>客户端使用代理对象进行编程，所以修改被代理对象的代码时，客户端无需修改代码，符合开闭原则</li><li>使用远程代理时，可以将运算复杂的业务放置在高性能服务器中，提升了系统整体的运行效率</li><li>使用虚拟代理时，可以懒加载某些需要庞大性能的对象，节省了系统资源</li><li>使用缓冲代理时，可以对运算结果进行临时缓存，共享给后续运算步骤，优化了系统性能</li><li>使用保护代理时，可以控制对象的访问权限，给不同的客户端分配不同的使用权限</li></ol></li><li><p>缺点：</p><ol><li>由于多了代理层，可能会造成业务处理速度降低（例如：保护代理，需要进行权限检查，而权限检查需要耗费系统资源）</li><li>某些代理模式的实现方式十分复杂（例如：Java中的RMI（远程代理），需要序列化对象，反序列化对象等一系列操作）</li></ol></li><li><p>作用：提供某个对象的代理对象，由代理对象来控制对原来对象的访问</p></li><li><p>分类：</p><ol><li>远程代理：使得客户端能使用远程服务器中的方法</li><li>虚拟代理：对加载时间长的对象，先使用“虚假”的代理对象来代表真实对象，等真实对象加载完毕后，虚拟代理将请求转发给真实对象</li><li><strong>静态代理</strong>：代理类和被代理类都必须继承或实现相同的父类或接口，代理类持有被代理类的成员变量，并且重写父类方法，调用被代理类中相同的方法（这样会导致代理类的数量过多）</li><li><strong>JDK动态代理</strong>：能够在系统运行时，根据需要动态的创建代理类，使得同一个代理类能代理多个不同的被代理类，常用于事务管理、AOP编程等（被代理的对象必须实现或继承它原本的父类或接口）</li><li><strong>CGLIB(Code Generation Library)动态代理</strong>：与JDK动态代理相比，被代理的类也不需要实现接口或者继承父类</li><li>保护代理：对于某些敏感的对象，在调用前，代理对象会检查客户是否具有权限，没有权限则不允许调用</li><li>缓冲代理：对于计算量较大的对象，通过在客户端或者服务端创建缓冲代理对象，避免每次调用都进行重复计算</li><li>智能引用代理：代理对象内部计数器计算调用次数，当没有使用者调用时，则该自动释放该代理对象</li></ol></li><li><p>类图：下图为静态代理模式的类图，代理对象与被代理对象都必须实现相同的接口，代理对象可以在调用被代理对象方法的时候，进行一些额外的操作</p><p><img src="/assets/image-20200726114532383.png" alt="image-20200726114532383"></p></li><li><p>使用场景：</p><ol><li>客户都安需要访问远程服务器中的对象，可以使用远程代理</li><li>可以通过虚拟代理缩短系统的启动时间</li><li>对频繁访问的计算结果，使用缓冲代理进行缓存</li><li>需要对调用方进行权限控制，可以使用保护代理</li><li>需要为某个对象的引用提供额外功能时，可以使用智能引用代理（例如：某个对象的引用次数为0，则可以释放该对象）</li></ol></li></ol></li></ul></li><li><h3 id="行为型：关注方法层面的调用"><a href="#行为型：关注方法层面的调用" class="headerlink" title="行为型：关注方法层面的调用"></a>行为型：关注方法层面的调用</h3><ul><li><h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><ol><li><p>优点：</p><ol><li>抽象出公共步骤，复用了代码</li><li>子类实现具体的细节，便于替换与扩展算法实现</li><li>类的行为由父类控制，子类负责实现</li></ol></li><li><p>缺点：</p><ol><li><p>修改骨架十分困难</p></li><li><p>会导致类数量过多</p></li><li><p>作用：定义一系列的算法步骤，将实现延迟到子类，使得子类能够不改变算法的整体结构，重新定义某些特定的算法步骤</p></li><li><p>类图：子类通过重写钩子方法可以决定是否执行某些算法步骤</p><p><img src="/assets/image-20200729104917807.png" alt="image-20200729104917807"></p></li><li><p>使用场景：</p><ol><li>需要控制子类的扩展，以符合算法规则</li><li>不同的类中，存在相同的业务流程，出现大量重复代码</li></ol></li></ol></li></ol></li><li><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><ol><li><p>优点：</p><ol><li>实现请求的调用者与请求的执行者解耦</li><li>可以实现不同的命令子类，扩展性好</li></ol></li><li><p>缺点：会导致类的数量过多</p></li><li><p>作用：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。</p></li><li><p>类图：通过栈保存命令调用的历史，以此达到撤销命令，还可以结合组合模式执行宏命令（一系列的命令批量执行）</p><p><img src="/assets/image-20200730160633409.png" alt="image-20200730160633409"></p></li><li><p>使用场景：</p><ol><li>需要撤销多次处理</li><li>实现原子事务（出现异常需要回滚）</li><li>命令含义稳定，并且希望解耦命令的调用者与执行者</li></ol></li></ol></li><li><h4 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h4><ol><li><p>优点：</p><ol><li>增加新的访问者（访问操作）十分方便，满足开闭原则</li><li>将访问的行为内聚到访问者对象中，让类的职责更清晰，使得复杂对象可供多个不同的访问者访问</li><li>不修改结构层次关系，却能对层次添加操作</li></ol></li><li><p>缺点：</p><ol><li>新增具体元素类，不符合开闭原则，每个访问者对象都需要进行修改</li><li>访问者访问的元素必须暴露某些内部操作、状态供其使用，破坏了对象的封装性</li></ol></li><li><p>作用：对操作复杂对象中的不同部分，在改变原有类的前提下，提供不同的操作方法</p></li><li><p>类图：</p><p><img src="/assets/image-20200802153201574.png" alt="image-20200802153201574"></p></li><li><p>使用场景：</p><ol><li>一个复杂对象中，存在多种不同的对象，希望根据不同的访问者对这些对象进行不同的操作</li><li>复杂对象的结构稳定，并且需要经常为其添加新的操作方式</li><li>希望对复杂对象的访问操作分离，避免大量的操作方式让复杂对象过于臃肿</li></ol></li></ol></li><li><h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><ol><li><p>优点：</p><ol><li>将遍历对象与存储对象分离，使得遍历时无需知道其内部结构，降低了耦合性</li><li>通过实现不同的迭代器可以替换遍历算法，并且为不同对象的遍历提供了统一的编程方式</li><li>对某个聚合对象添加新的遍历算法，只需要实现新的迭代器，符合开闭原则</li></ol></li><li><p>缺点：</p><ol><li>实现不同的遍历器类会导致类数量过多(可以通过内部类实现解决)</li><li>对遍历器接口的设计要求很高，若要修改遍历接口，则不符合开闭原则</li><li>遍历时，不能修改被遍历的集合，否则会遍历出错</li></ol></li><li><p>作用：提供一种方法访问聚合对象，而无需知道其内部结构</p></li><li><p>类图：使用内部类来实现具体迭代器类</p><p><img src="/assets/image-20200804084117099.png" alt="image-20200804084117099"></p></li><li><p>使用场景：</p><ol><li>访问某个对象的元素而无需暴露其内部结构</li><li>需要为某个对象提供多种遍历方式</li><li>为不同对象的遍历方式提供统一的遍历操作接口，使得客户端能够统一遍历方式</li></ol></li></ol></li><li><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><ol><li><p>优点：</p><ol><li>将表示层与数据层分离，使得不同层次的对象都可以充当观察者</li><li>观察者与被观察者通过抽象耦合，它们无需知道对方具体的实现细节，便可以与对方进行通信</li><li>简化了一对多的广播通信等系统的设计难度</li><li>增加新的具体观察者符合开闭原则；当观察者与被观察者没有关联时，新增被观察者也十分方便</li></ol></li><li><p>缺点：</p><ol><li>观察者过多，会导致推送更新的时间过长</li><li>若观察者和被观察的对象之间存在循环依赖，则观察者模式会触发死循环</li><li>观察者无法知道是什么原因导致被观察的目标发生变化</li></ol></li><li><p>作用：定义对象之间的一对多关系，使得一个对象的状态发生改变，它的观察者都能收到通知并且更新自身持有的信息</p></li><li><p>类图：</p><p><img src="/assets/image-20200804221620143.png" alt="image-20200804221620143"></p></li><li><p>使用场景：</p><ol><li>存在两个抽象的模型，且一方依赖于另外一方，则可使用观察者模式在抽象层进行关联，使得它们能够独立的改变与复用</li><li>一个对象的改变需要通知其他对象也发生改变，并且不知道这些对象的类型与数量</li><li>可以使用观察者模式形成触发链</li></ol></li></ol></li><li><h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><ol><li><p>优点：</p><ol><li>将对象间多对多的关联关系转换成一对多的关联关系，简化了编程的复杂度，更容易维护与理解、扩展</li><li>解耦具体同事类之间的关联关系，使得它们能够相互独立变化，符合开闭原则</li><li>具体同事类可以被子中介者类复用，降低了类的数量</li></ol></li><li><p>缺点：中介者类中包含大量同事类的交互逻辑，难以维护，容易出错</p></li><li><p>作用：用一个中介对象封装一系列对象的交互，使这些对象无需显示引用对方，从而降低它们的耦合，让它们能独立变化</p></li><li><p>类图：同事类One和Two，通过中介者类进行通信。中介者根据具体的同事类，决定执行如何调用其他同事类</p><p><img src="/assets/Packageintermediary.png" alt="Packageintermediary"></p></li><li><p>使用场景：</p><ol><li>系统中的对象存在复杂的引用关系，系统结构混乱并且难以理解</li><li>某个对象引用了许多对象，并且与这些对象进行交互，并且希望能复用它</li><li>希望通过一个中间类封装多个类中的行为，又不希望创建过多的中间类</li></ol></li></ol></li><li><h4 id="备忘录模式（对象行为模式）"><a href="#备忘录模式（对象行为模式）" class="headerlink" title="备忘录模式（对象行为模式）"></a>备忘录模式（对象行为模式）</h4><ol><li><p>优点：</p><ol><li><p>提供对象状态恢复的机制，可用于对象变更成新状态遇到问题时，恢复老状态</p></li><li><p>通过栈等其他数据结构存储实现，可进行多次撤销操作，即使执行时状态产生了分支，也能回退</p></li><li><p>缺点：当状态对象过于复杂时，使用备忘录对象保存状态会造成过多的内存开销（需要只记录每次修改变动的部分解决此问题，但其实现将十分困难）</p></li><li><p>作用：不破坏对象内部封装的前提下，保存其内部状态到其他对象中，当需要恢复状态的时候进行恢复</p></li><li><p>类图：通过内部类和栈实现多步回退机制</p><p><img src="/assets/image-20200806203905578.png" alt="image-20200806203905578"></p></li><li><p>使用场景：</p><ol><li>需要保存某一时刻某个对象的所有状态，以便于后续进行恢复</li><li>希望将状态对象的变更历史保存到它自己当中，不希望其他对象修改它的变更历史</li></ol></li></ol></li></ol></li></ul></li></ol><ul><li><h4 id="解释器模式（类行为模式）"><a href="#解释器模式（类行为模式）" class="headerlink" title="解释器模式（类行为模式）"></a>解释器模式（类行为模式）</h4><ol><li><p>优点：</p><ol><li>能够轻松实现简单的文法规则，新增文法规则只需要添加新的实现类，符合开闭原则</li><li>具体节点类之间存在相似的结构，可以使用工具自动生成相关代码</li></ol></li><li><p>缺点：</p><ol><li>复杂的文法类的数量会过多</li><li>执行效率不高（因为解释复杂句子时，存在大量递归与循环调用，并且难以理解与调试）</li></ol></li><li><p>作用：定义一种语言文法，编写对应的解释器对其进行翻译，执行其具体含义</p></li><li><p>类图：定义抽象节点（BaseNode）、中间语法节点（ExpressionNode、CommandNode）、语法叶子节点（NonLoopNode、LoopNode），其中表达式节点由多个命令节点组成，命令节点由多个循环或者不循环叶子节点组成，最后通过上下文（Context类）携带的句子信息，使用ExpressionNode节点进行翻译与执行命令</p><p><img src="/assets/Packageinterpreter.png" alt="Packageinterpreter"></p></li><li><p>使用场景：</p><ol><li>执行效率要求不高，需要进行简单的文法转换</li><li>可以用简单文法描述的重复问题（例如：二维平面的移动，确定方向与距离，多次执行命令，便可以到达任何位置）</li></ol></li></ol></li><li><h4 id="状态模式（对象行为模式）"><a href="#状态模式（对象行为模式）" class="headerlink" title="状态模式（对象行为模式）"></a>状态模式（对象行为模式）</h4><ol><li><p>优点：</p><ol><li>将状态代码与状态对象解耦，便于集中管理控制状态的相关代码</li><li>持有不同的状态对象，可以具有不同的功能实现方式</li><li>可以通过环境对象共享状态对象，减少所需的具体状态类</li></ol></li><li><p>缺点：</p><ol><li>由于分离了环境对象与其状态，当状态的种类较多时，会产生较多的具体状态类</li><li>增加新状态需要修改那些负责转换状态的类，不符合开闭原则</li><li>分离状态代码会导致代码的设计难度提升</li></ol></li><li><p>作用：使得对象的内部状态发生改变，其行为也随之改变</p></li><li><p>类图：可通过状态类控制状态转换，也可以通过上下文类自身进行状态的控制，还可以通过静态状态成员变量在上下文对象间进行状态共享</p><p><img src="/assets/Packagestate.png" alt="Packagestate"></p></li><li><p>使用场景：</p><ol><li>对象的行为依赖自身的属性值</li><li>模块中存在大量处理、维护状态的语句</li></ol></li></ol></li><li><h4 id="策略模式（对象行为模式）"><a href="#策略模式（对象行为模式）" class="headerlink" title="策略模式（对象行为模式）"></a>策略模式（对象行为模式）</h4><ol><li>优点：<ol><li>完全符合开闭原则，可以不修改原有的代码进行新增、修改算法</li><li>通过抽象策略类可以复用公共的算法代码，并且具体策略也可以被其他上下文类复用</li><li>允许在运行时切换具体的算法实现，并且支持每种不同的算法独立扩展与修改</li><li>能够避免大量分支语句块的出现</li></ol></li></ol></li></ul><ol><li><p>缺点：</p><ol><li>客户端需要理解每种不同的算法，当算法种类过多时，学习成本较大</li><li>任何算法的变化都会新增具体策略类，会造成具体策略类过多</li><li>无法混用多种策略（比如使用A策略类的前三步，再用B策略类的后三步完成业务处理）</li></ol></li><li><p>作用：定义一系列的算法，由具体子类实现不同的算法，将这些算法封装起来，使得它们可以相互替换</p></li><li><p>类图：</p><p><img src="/assets/image-20200811084646661.png" alt="image-20200811084646661"></p></li><li><p>使用场景：</p><ol><li>模块的运行需要动态切换成某种不同的算法逻辑</li><li>业务逻辑存在大量分支语句，存在多重条件选择语句（例如 A &amp;&amp; B &amp;&amp; C），可以通过策略分发的方式消除</li><li>不希望客户端知道算法的具体实现逻辑</li></ol></li></ol><ul><li><h4 id="责任链（职责链）模式（对象行为模式）"><a href="#责任链（职责链）模式（对象行为模式）" class="headerlink" title="责任链（职责链）模式（对象行为模式）"></a>责任链（职责链）模式（对象行为模式）</h4><ol><li><p>分类:</p><ul><li>完全（纯职责）职责模式：<ol><li>请求只能被职责链中的某一个环节处理，不能继续转发至其他节点</li><li>不能出现请求没有节点处理的情况</li></ol></li><li>不完全（不纯）职责模式：<ol><li>请求被某个节点处理后，可以继续传递给后续节点进行处理</li><li>可以出现请求没有被任何节点处理的情况</li></ol></li></ul></li><li><p>优点：</p><ol><li>请求对象与处理对象进行解耦，职责链由客户端创建，降低系统的耦合度</li><li>每一位请求处理者只需要维持后一位处理者的引用，而无需知晓全部处理者</li><li>可以在运行时修改职责链，从而动态改变处理流程</li><li>新增处理节点时，符合开闭原则</li></ol></li><li><p>缺点：</p><ol><li>请求可能会因为职责链的配置错误而无法正确处理</li><li>职责链过长，处理性能会受影响，并且调试难度增加</li></ol></li><li><p>作用：将请求发送者与请求处理者分离（由多个处理对象组成一条处理链，请求沿着链条传递，直到有对象能对请求进行处理）</p></li><li><p>类图：</p><p><img src="/assets/Packagechain.png" alt="Packagechain"></p></li><li><p>使用场景：</p><ol><li>多个对象都能处理一个请求，并且需要运行时才确定使用哪个对象进行处理，客户端不关心具体处理请求的对象</li><li>想要动态改变请求处理者的先后顺序、处理者的数量等职责链相关的属性</li></ol></li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式学习笔记&quot;&gt;&lt;a href=&quot;#设计模式学习笔记&quot; class=&quot;headerlink&quot; title=&quot;设计模式学习笔记&quot;&gt;&lt;/a&gt;设计模式学习笔记&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;h2 id=&quot;七大设计原则&quot;&gt;&lt;a href=&quot;#七大设计原则&quot; class=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://b727031867.github.io/2020/10/10/Spring%E7%AC%94%E8%AE%B0/"/>
    <id>https://b727031867.github.io/2020/10/10/Spring%E7%AC%94%E8%AE%B0/</id>
    <published>2020-10-10T12:12:43.998Z</published>
    <updated>2020-10-10T14:33:47.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h1><ol><li><h2 id="特性：ACID"><a href="#特性：ACID" class="headerlink" title="特性：ACID"></a>特性：ACID</h2><ul><li>原子性：事务执行的基本单位，保证一个或多个操作<strong>要么全部成功，要么全部失败</strong>，没有中间状态，失败则回滚至初始状态。</li><li>一致性：<strong>指系统从一个正确的状态,迁移到另一个正确的状态</strong>。这是通过AID来保证的，即事务同时具备原子性、隔离性、持久性，才能保证事务的一致性。</li><li>隔离性：不同的事务在提交以前应当对其他事务不可见，但是根据实际情况会分为以下四种隔离级别：<ul><li>脏读：事务A读取了事务B的中间值，导致数据运算结果不准确。</li><li>不可重复读（重点在于修改）：事务A多次读取结果不同，因为事务B在事务A读取的间隙修改了数据。</li><li>幻读（重点在于新增与删除）：与不可重复读类似，事务A查询期间事务B插入了数据，事务A再次查询发现多了几条数据（两次数据查询都在同一个事务中）</li><li>修改丢失：事务A与事务B同时修改同一数据，导致后完成的事务覆盖之前事务的结果。</li></ul></li><li>持久性：事务执行后涉及的数据将存入存储系统，不会回滚。</li></ul></li><li><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><ol><li><strong>TransactionDefinition.ISOLATION_DEFAULT</strong>：采用数据库默认的隔离级别。MySQL为可重复读，Oracle为采用可提交读。此为默认设置</li><li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</strong>：读未提交数据，可以看见其他事务处理中的数据，隔离级别最低</li><li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED</strong>：可以读已提交数据（可提交读），能够在A事务中读取B事务的修改与插入的数据。</li><li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ</strong>：可重复读，能够在A事务中读取B事务的插入的新数据，无法读取B事务中对旧数据的更新。</li><li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE</strong>：串行化执行，隔离级别最高</li></ol></li><li><h2 id="隔离级别与并发问题"><a href="#隔离级别与并发问题" class="headerlink" title="隔离级别与并发问题"></a>隔离级别与并发问题</h2><ul><li><p>一类更新：回滚丢失（Lost update）：对同一数据，事务A与事务B分别执行，事务B提交完毕，事务A回滚，结果回滚撤销了事务B的提交（就像事务B没有执行），<strong>所有隔离级别都不允许回滚丢失</strong>。</p></li><li><p>二类更新：多次更新丢失（Second lost update）：事务A与事务B对同一数据进行修改，事务A修改后提交，但事务B的修改基于修改前的值，导致事务B修改后覆盖了事务A提交的值。</p><table><thead><tr><th align="center">隔离级别</th><th align="center">一类更新</th><th align="center">二类更新</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">读未提交</td><td align="center">否</td><td align="center">是</td><td align="center">是</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="center">读已提交</td><td align="center">否</td><td align="center">是</td><td align="center">否</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="center">可重复读</td><td align="center">否</td><td align="center">否</td><td align="center">否</td><td align="center">否</td><td align="center">是</td></tr><tr><td align="center">串行化</td><td align="center">否</td><td align="center">否</td><td align="center">否</td><td align="center">否</td><td align="center">否</td></tr></tbody></table></li></ul></li><li><h2 id="传播特性（7种）"><a href="#传播特性（7种）" class="headerlink" title="传播特性（7种）"></a>传播特性（7种）</h2><ul><li>支持当前事务：<ol><li>PROPAGATION_REQUIRED：当前存在事务则沿用，否则开启新事务</li><li>PROPAGATION_SUPPORTS：事务不做强制要求（有就用事务，没有就不用）</li><li>PROPAGATION MANDATORY：有事务则加入事务，没有事务则抛异常</li></ol></li><li>不支持当前事务：<ol><li>PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li>PROPAGATION_NOT_SUPPORTED：非事务运行，若存在事务，则把当前事务挂起。</li><li>PROPAGATION_NEVER：用非事务模式运行，存在事务则抛异常</li></ol></li><li>其他:<ol><li>ROPAGATION_NESTED：存在事务，则开启一个子事务（子事务回滚，不影响外部事务，而外部事务回滚会导致子事务回滚），当前没有事务则等同于PROPAGATION_REQUIRED</li></ol></li></ul></li><li><h2 id="控制事务运行的方法"><a href="#控制事务运行的方法" class="headerlink" title="控制事务运行的方法"></a>控制事务运行的方法</h2><p> 在<strong>TransactionStatus接口</strong>中，可以设置事务超时时间、是否只读（可以增加性能）以下为常用方法：</p><ul><li><strong>isNewTransaction</strong>(); // 是否是新的事物</li><li><strong>hasSavepoint</strong>(); // 是否有恢复点</li><li><strong>isRollbackOnly</strong>(); // 是否为只回滚</li><li><strong>boolean</strong>  isCompleted：是否完成</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring事务&quot;&gt;&lt;a href=&quot;#Spring事务&quot; class=&quot;headerlink&quot; title=&quot;Spring事务&quot;&gt;&lt;/a&gt;Spring事务&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;h2 id=&quot;特性：ACID&quot;&gt;&lt;a href=&quot;#特性：ACID&quot; clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://b727031867.github.io/2020/10/10/Java%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://b727031867.github.io/2020/10/10/Java%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2020-10-10T12:12:43.995Z</published>
    <updated>2020-10-10T14:17:22.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-8-函数式编程读书笔记"><a href="#Java-8-函数式编程读书笔记" class="headerlink" title="Java 8 函数式编程读书笔记"></a>Java 8 函数式编程读书笔记</h1><ol><li><h3 id="函数式接口：只有单个抽象方法的接口"><a href="#函数式接口：只有单个抽象方法的接口" class="headerlink" title="函数式接口：只有单个抽象方法的接口"></a>函数式接口：只有单个抽象方法的接口</h3><ol><li><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 龚秀峰</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/9/29 22:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//上述定义了一个函数接口，其中有一个方法test，该方法接收两个泛型对象参数，返回一个泛型对象</span></span><br><span class="line">    <span class="function">T <span class="title">test</span><span class="params">(T param1,T param2)</span></span>;</span><br><span class="line">    <span class="comment">//函数接口中只能定义一个方法，定义多个方法会导致注解FunctionalInterface报错</span></span><br><span class="line">    <span class="comment">//Multiple non-overriding abstract methods found in xxx</span></span><br><span class="line">    <span class="comment">//这是因为，Java中存在的类型重载，会让javac挑选最明确的类型，但是拉姆达表达式是一段代码，而不是一种类型</span></span><br><span class="line">    <span class="comment">//所以无法进行挑选。为了避免歧义，让函数式接口中只能存在一个接口方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">implements</span> <span class="title">Test</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String resStr = <span class="keyword">new</span> MyClass().test(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//下面想要通过拉姆达表达式创建类或抽象类的对象，让对象具有不同的行为，不允许！</span></span><br><span class="line">        <span class="comment">//new MyClass().test((param1,param2) -&gt; param1 + param2 * param1);</span></span><br><span class="line">        <span class="comment">//会报错：Target type of a lambda conversion must be an interface</span></span><br><span class="line">        System.out.println(resStr);</span><br><span class="line">        <span class="comment">//使用拉姆达表达式，传入另外一种行为，使得接口的ｔｅｓｔ方法具有其他的行为</span></span><br><span class="line">        Test&lt;Integer&gt; iTest = (param1,param2) -&gt; param1 + param2 * param1;</span><br><span class="line">        Integer res = iTest.test(<span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传统的实现接口方式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String param1, String param2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> param1 + param2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>运行结果：</p><p><img src="/assets/image-20200929221059823.png" alt="image-20200929221059823"></p></li><li><p>常用的函数接口</p><ul><li><strong>Supplier</strong><T>：无参数，返回一种结果，T为结果类型</li><li><strong>Consumer<T></strong>:接收一个参数，但无返回值，T为参数类型</li><li>**Function&lt;T,R&gt;**： 接收一种参数，返回一种结果，T为参数类型，R为结果类型</li><li><strong>Predicate<T></strong> ：接收参数，返回Boolean值</li></ul></li><li><p>高级函数接口：就是定义的参数中包含函数接口，使得高级函数可以传入普通函数（拉姆达表达式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//此方法是高级函数，它的第二个参数可以接收一个拉姆达表达式</span></span><br><span class="line">    <span class="function">T <span class="title">test</span><span class="params">(T param1,Supplier&lt;T&gt; handler)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>默认方法：为了解决接口新增方法时，所有实现类都必须实现新增的方法的问题，不实现抽象方法的类则采用默认方法中的实现。下图是jdk中集合遍历的默认实现：</p><p><img src="/assets/image-20201005222721432.png" alt="image-20201005222721432"></p><p>默认方法的特点：</p><ul><li>需要添加default关键字</li><li>只能使用子类的方法修改子类自身，无需知晓子类的具体实现（因为接口本身没有成员变量）</li><li>子类中存在该方法，那么会采用子类中的方法（类中重写的方法比默认方法更具体，因此优先级高）</li><li>接口可以多继承，多重继承时，出现相同优先级的默认方法，则编译不通过，除非手动选择方法（例如：通过在实现方法中，使用XXX.super关键字，指明XXX是谁，调用的默认方法就是谁的）</li></ul></li><li><p>接口中的静态方法：</p><ol><li><pre><code class="java">Stream&lt;T&gt; of(T t)//从一个集合中获取流，按照顺序有序生成Stream&lt;T&gt; of(T... values)//从数组中获取流，按照顺序有序生成<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. &#96;&#96;&#96;java</span><br><span class="line">   Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) &#x2F;&#x2F;生成流，第一个参数为初始值，第二个参数为根据初始值生成新的初始值，此方法一般要配合limit使用，否则会无限生成流</span><br><span class="line">   Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)&#x2F;&#x2F;通过函数生成流对象</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="java">Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)//连接两个流<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">7. Optional：可以看作是一个值容器，并且能够容纳null值</span><br><span class="line"></span><br><span class="line">   1. 用法：</span><br><span class="line">   </span><br><span class="line">      &#96;&#96;&#96;java</span><br><span class="line">      class B&lt;T&gt;&#123;</span><br><span class="line">      </span><br><span class="line">          public static void main(String[] args) &#123;</span><br><span class="line">              B&lt;String&gt; stringB &#x3D; new B&lt;&gt;();</span><br><span class="line">              stringB.testOptional(&quot;666&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">          public void testOptional(T obj)&#123;</span><br><span class="line">              &#x2F;&#x2F;构造一个空optional对象</span><br><span class="line">              Optional&lt;T&gt; optional &#x3D; Optional.empty();</span><br><span class="line">              &#x2F;&#x2F;将传入对象化为optional对象</span><br><span class="line">              Optional&lt;T&gt; optional2 &#x3D; Optional.ofNullable(obj);</span><br><span class="line">              &#x2F;&#x2F;判断这两个optional对象是否相同</span><br><span class="line">              boolean equals &#x3D; optional.equals(optional2);</span><br><span class="line">              System.out.println(equals);</span><br><span class="line">              &#x2F;&#x2F;判断obj对象的optional对象与obj对象是否相同</span><br><span class="line">              equals &#x3D; optional2.equals(obj);</span><br><span class="line">              System.out.println(equals);</span><br><span class="line">              &#x2F;&#x2F;如果optional不为空，那么执行拉姆达表达式的内容</span><br><span class="line">              optional.ifPresent(System.out::println);</span><br><span class="line">              &#x2F;&#x2F;如果optional存在，那么返回optional，否则返回参数中的值</span><br><span class="line">              T t &#x3D; optional.orElse(obj);</span><br><span class="line">              System.out.println(&quot;orElse值是：&quot; + t);</span><br><span class="line">              &#x2F;&#x2F;如果optional2有值，那么会返回值，否则使用拉姆达表达式返回的值(上面的t)</span><br><span class="line">              Supplier&lt;T&gt; supplier &#x3D; ()-&gt;t;</span><br><span class="line">              T t1 &#x3D; optional2.orElseGet(supplier);</span><br><span class="line">              System.out.println(&quot;orElseGet值是：&quot; + t1);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol></li></ol></li></ol><pre><code>  2. 注意：     - 当希望使用Optional作为参数时，最好使用采用重载实现，因为用Optional作为参数会让调用方复杂     - 当返回值为Optional类型时，调用方必须去处理，以此减少空指针的问题</code></pre><ol start="2"><li><h3 id="拉姆达表达式"><a href="#拉姆达表达式" class="headerlink" title="拉姆达表达式"></a>拉姆达表达式</h3><ol><li><p>作用：传递一种行为（代码块），使得同一个函数接口具有不同的行为</p></li><li><p>基本语法：</p><ul><li>无参拉姆达表达式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行的代码只有一行</span></span><br><span class="line">Runnable noParamsForOneRow = ()-&gt; System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">//多行执行代码</span></span><br><span class="line">Runnable noParamsForManyRow = ()-&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">                                   &#125;;</span><br><span class="line"><span class="comment">//以上的noParamsForOneRow、noParamsForManyRow作为函数接口，可以传入高阶函数（高阶函数能够接收拉姆达表达式），让高阶函数具有不同的行为。以上方法都没有返回值，相当于重写Runnable中的run方法</span></span><br></pre></td></tr></table></figure><ul><li>一个或多个参数的拉姆达表达式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 龚秀峰</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/9/29 22:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span>&lt;<span class="title">T</span>,<span class="title">R</span>,<span class="title">C</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">test</span><span class="params">(T param1,C param2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">implements</span> <span class="title">Test</span>&lt;<span class="title">String</span>,<span class="title">Long</span>,<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里Double作为返回类型，Double、Long作为参数类型，通过拉姆达表达式传入不同的行为</span></span><br><span class="line">        Test&lt;Double,Double,Long&gt; iTest = (param1,param2) -&gt; param1 + param2 * param1;</span><br><span class="line">        <span class="comment">//不省略参数的类型</span></span><br><span class="line">        Test&lt;Double,Double,Long&gt; iTest2 = (Double param1,Long param2) -&gt; param1 + param2 * param1;</span><br><span class="line">        <span class="comment">//多行要执行的语句，依旧是返回Double类型的值</span></span><br><span class="line">        Test&lt;Double,Double,Long&gt; iTest3 = (Double param1,Long param2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">double</span> temp = <span class="number">0D</span>;</span><br><span class="line">            temp += param1 + param2 * param1;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;;</span><br><span class="line">        Double res = iTest.test(<span class="number">6D</span>, <span class="number">1L</span>);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传统实现接口的方式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">test</span><span class="params">(String param1, Integer param2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span>)(param1.length() + param2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.checkerframework.checker.nullness.qual.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GXF</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 0.1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-10-05 12:40</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 0.1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//静态方法引用，将test方法的方法体作为run方法的方法体</span></span><br><span class="line">        Runnable test = A::test;</span><br><span class="line">        <span class="keyword">new</span> Thread(test).start();</span><br><span class="line">        <span class="comment">//构造器引用，将一个参数的构造器作为创建A对象的生产者</span></span><br><span class="line">        Function&lt;String, <span class="meta">@Nullable</span> A&gt; constructor = name -&gt; name != <span class="keyword">null</span> ? <span class="keyword">new</span> A(name) : <span class="keyword">null</span>;</span><br><span class="line">        A a2 = constructor.apply(<span class="string">&quot;777&quot;</span>);</span><br><span class="line">        <span class="keyword">assert</span> a2 != <span class="keyword">null</span>;</span><br><span class="line">        a2.sayName();</span><br><span class="line">        <span class="comment">//构造器引用，将默认构造器作为创建A对象的生产者</span></span><br><span class="line">        A a = A.create(A::<span class="keyword">new</span>);</span><br><span class="line">        <span class="comment">//实例方法引用，将sayName代码块作为run方法的执行体，</span></span><br><span class="line">        Runnable sayName = a::sayName;</span><br><span class="line">        <span class="keyword">new</span> Thread(sayName).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;默认名称&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> A <span class="title">create</span><span class="params">(Supplier&lt;A&gt; constructor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> constructor.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li></ol><ol start="3"><li><p>注意：</p><ol><li><p><strong>拉姆达表达式中，如果要引用外部的变量，那么该变量必须是<em>既定事实上不变的</em></strong>（所以拉姆达表达式中引用外部的变量实际上是引用外部的值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如:下面的拉姆达表达式使用了变量t ，但是t不被修改，因此即使t没有final关键字修饰，也不会报错</span></span><br><span class="line"><span class="keyword">double</span> t = <span class="number">20D</span></span><br><span class="line">Test&lt;Double,Double,Long&gt; iTest3 = (Double param1,Long param2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">double</span> temp = <span class="number">0D</span>;</span><br><span class="line">         temp += (param1 + param2 * param1) - t;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="comment">//下面是报错的情况</span></span><br><span class="line">Test&lt;Double,Double,Long&gt; iTest3 = (Double param1,Long param2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">double</span> temp = <span class="number">0D</span>;</span><br><span class="line">    <span class="comment">//这里修改了外部变量t，所以会报错</span></span><br><span class="line">    t = <span class="number">10D</span></span><br><span class="line">            temp += (param1 + param2 * param1) - t;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></li><li><p>为何拉姆达表达式中可以省略参数类型呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据javac中的类型推断，可以从拉姆达表达式的上下文中推断出参数类型、返回值类型，因此可以省略不写参数类型、返回类型</span></span><br><span class="line">Test&lt;Double,Double,Long&gt; iTest = (param1,param2) -&gt; param1 + param2 * param1;</span><br></pre></td></tr></table></figure></li><li><p>拉姆达表达式可以看作代码块，通过传递代码块来传递行为，同一个函数接口由于传入了不同的行为产生了不同的功能，这是一种多态的体现，可以用于优化某些设计模式，例如：策略模式、命令模式、观察者模式等，无需创建过多的子类，也能达成同一个接口多种行为的目的，但是，对于复杂的接口，不建议采用拉姆达表达式进行简化，应该使用不同的类来实现接口</p></li></ol></li></ol><ol start="3"><li><h3 id="Steam-流"><a href="#Steam-流" class="headerlink" title="Steam(流)"></a>Steam(流)</h3><ol><li><p>作用：用函数式编程更加清晰简洁的操作集合</p></li><li><p>特性：</p><ol><li>流不可复用：用于进行过滤、求值操作后，再进行其他操作则会报错</li><li>惰性求值：只有当使用<strong>及时求值</strong>方法的时候，才会真正进行计算</li></ol></li><li><p>常用流操作：</p><ol><li>过滤器（filter）</li></ol></li></ol></li></ol><pre><code>  2. 转换器（map）  3. 缩放转换器（flatmap）  4. 累积操作器（reduce）  5. 收集器（Collect）</code></pre><ol start="4"><li><p>并行流：</p></li><li><p>注意：</p><ul><li>基本类型应该使用其对应的流，避免自动装箱、拆箱，降低性能</li><li>并行流采用ForkJoinPool（共享线程池），默认会配分CPU个数的线程，适合CPU密集型的应用，若应用属于IO密集型，则需要自行修改成其他线程池</li><li>流对象的顺序与元素的出现顺序相同，即与集合顺序一致，但是当集合无序，那么生成的流也无序，<strong>流的顺序会影响流操作的效率，也会影响并行操作的结果</strong></li></ul></li></ol><ol start="4"><li><h3 id="重构旧代码与测试拉姆达表达式"><a href="#重构旧代码与测试拉姆达表达式" class="headerlink" title="重构旧代码与测试拉姆达表达式"></a>重构旧代码与测试拉姆达表达式</h3></li><li><h3 id="拉姆达与并发"><a href="#拉姆达与并发" class="headerlink" title="拉姆达与并发"></a>拉姆达与并发</h3></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-8-函数式编程读书笔记&quot;&gt;&lt;a href=&quot;#Java-8-函数式编程读书笔记&quot; class=&quot;headerlink&quot; title=&quot;Java 8 函数式编程读书笔记&quot;&gt;&lt;/a&gt;Java 8 函数式编程读书笔记&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://b727031867.github.io/2020/10/10/Java%20NIO%E7%9F%A5%E8%AF%86/"/>
    <id>https://b727031867.github.io/2020/10/10/Java%20NIO%E7%9F%A5%E8%AF%86/</id>
    <published>2020-10-10T12:12:43.993Z</published>
    <updated>2020-05-01T07:18:41.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h1><h3 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h3><ul><li><p>面向缓冲区(缓冲区可以双向移动，通过管道传输)</p></li><li><p>非阻塞IO</p></li><li><p>具有选择器</p></li></ul><h3 id="通道与缓冲区"><a href="#通道与缓冲区" class="headerlink" title="通道与缓冲区"></a>通道与缓冲区</h3><ul><li><h4 id="通道（Channel）：负责传输"><a href="#通道（Channel）：负责传输" class="headerlink" title="通道（Channel）：负责传输"></a>通道（Channel）：负责传输</h4><ol><li><p>描述：表示目标与I/O资源的连接，类似流，但不能直接访问数据，只能与Buffer交互</p></li><li><p>用途：解决原本DMA设计下，多个IO并发造成总线拥堵的情况</p></li><li><p>特点：CPU利用率高，无需再向CPU申请IO</p></li><li><p>类型：</p><ol><li>本地I/O<ul><li>FileChannel（阻塞的，没有继承SelectableChannel）：FileInputStream/FileOutputStream</li><li>RandomAccessFile</li></ul></li><li>网络I/O<ul><li>SocketChannel：TCP</li><li>ServerSocketChannel：TCP</li><li>DatagramChannel：UDP</li></ul></li></ol></li><li><p>获取方法</p><ol><li>支持通道的类调用getChannel()方法获取对应通道</li><li>JDK1.7后，NIO2针对通道获取提供静态方法open()</li><li>JDK1.7后，NIO2的Files工具类可以用newByteChannel()获取通道</li></ol></li><li><p>使用方法</p><ul><li>下面使用<strong>非直接缓冲区</strong>读取a图片的流输出到b图片中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取某文件输出与输出管道,并且由Java自动关闭流</span></span><br><span class="line"><span class="keyword">try</span> (FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;a.png&quot;</span>);</span><br><span class="line">     FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;b.png&quot;</span>);</span><br><span class="line">     FileChannel fileChannel1 = fileInputStream.getChannel();</span><br><span class="line">     FileChannel fileChannel2 = fileOutputStream.getChannel();</span><br><span class="line">     ) &#123;</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">while</span> (fileChannel1.read(byteBuffer) != -<span class="number">1</span>)&#123;</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        fileChannel2.write(byteBuffer);</span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用<strong>直接缓冲区</strong>读取a图片的流输出到b图片中（只有ByteBuffer支持）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (</span><br><span class="line">    <span class="comment">//通过静态方法直接获取对应文件的I/O读、写管道</span></span><br><span class="line">    FileChannel fileInChannel = FileChannel.open(Paths.get(<span class="string">&quot;a.png&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">    <span class="comment">//允许写通道覆盖的写入b.png、支持读与写</span></span><br><span class="line">    FileChannel fileOutChannel = FileChannel.open(Paths.get(<span class="string">&quot;b.png&quot;</span>), StandardOpenOption.WRITE,StandardOpenOption.READ,StandardOpenOption.CREATE)</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">//映射将缓冲区到非直接内存中</span></span><br><span class="line">    MappedByteBuffer inByteBuffer = fileInChannel.map(FileChannel.MapMode.READ_ONLY,<span class="number">0</span>,fileInChannel.size());</span><br><span class="line">    MappedByteBuffer outByteBuffer = fileOutChannel.map(FileChannel.MapMode.READ_WRITE,<span class="number">0</span>,fileInChannel.size());</span><br><span class="line">    <span class="comment">//创建读取内容所需的字节数组，大小设置为总大小</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[inByteBuffer.capacity()];</span><br><span class="line">    <span class="comment">//读取内容到缓冲区中</span></span><br><span class="line">    inByteBuffer.get(bytes);</span><br><span class="line">    <span class="comment">//把缓冲区中的内容通过管道写入文件b.png中,需要StandardOpenOption.READ和StandardOpenOption.WRITE</span></span><br><span class="line">    outByteBuffer.put(bytes);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="通道之间数据传输-transferFrom-与transferTo-方法可以直接在两个管道之间交互数据"><a href="#通道之间数据传输-transferFrom-与transferTo-方法可以直接在两个管道之间交互数据" class="headerlink" title="通道之间数据传输:**transferFrom()与transferTo()**方法可以直接在两个管道之间交互数据"></a>通道之间数据传输:**transferFrom()与transferTo()**方法可以直接在两个管道之间交互数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (</span><br><span class="line">        <span class="comment">//通过静态方法直接获取对应文件的I/O读、写管道</span></span><br><span class="line">        FileChannel inChannel = FileChannel.open(Paths.get(<span class="string">&quot;a.png&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">        <span class="comment">//允许写通道覆盖的写入b.png、支持读与写</span></span><br><span class="line">        FileChannel outChannel = FileChannel.open(Paths.get(<span class="string">&quot;b.png&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE)</span><br><span class="line">) &#123;</span><br><span class="line">        <span class="comment">//将in管道的内容写入out管道(利用直接缓冲区)</span></span><br><span class="line">        inChannel.transferTo(<span class="number">0</span>,inChannel.size(),outChannel);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="分散-Scatter-与聚集-Gather"><a href="#分散-Scatter-与聚集-Gather" class="headerlink" title="分散(Scatter)与聚集(Gather)"></a>分散(Scatter)与聚集(Gather)</h5><ol><li><p>分散读取：将从管道中读取的数据<strong>按顺序</strong>“分散”填满多个Buffer中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (</span><br><span class="line">        <span class="comment">//获取文件</span></span><br><span class="line">        RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="comment">//获取文件IO管道</span></span><br><span class="line">        FileChannel channel = file.getChannel();</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">//分配缓冲区大小</span></span><br><span class="line">    ByteBuffer b1 = ByteBuffer.allocate(<span class="number">2</span>);</span><br><span class="line">    ByteBuffer b2 = ByteBuffer.allocate(<span class="number">200</span>);</span><br><span class="line">    <span class="comment">//分别读取</span></span><br><span class="line">    ByteBuffer[] byteBuffers = &#123;b1, b2&#125;;</span><br><span class="line">    channel.read(byteBuffers);</span><br><span class="line">    <span class="keyword">for</span> (ByteBuffer byteBuffer : byteBuffers) &#123;</span><br><span class="line">        <span class="comment">//修改缓冲区为写模式</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;-------b1-------&quot;</span>);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(b1.array()));</span><br><span class="line">    System.out.println(<span class="string">&quot;-------b2-------&quot;</span>);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(b2.array()));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>聚集写入：将多个Buffer按照缓冲区的顺序将position到limit的数据汇集到管道中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 聚集写入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testGather</span><span class="params">(ByteBuffer[] byteBuffers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">            <span class="comment">//获取文件</span></span><br><span class="line">            RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;b.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">            <span class="comment">//获取文件IO管道</span></span><br><span class="line">            FileChannel channel = file.getChannel();</span><br><span class="line">    ) &#123;</span><br><span class="line">        channel.write(byteBuffers);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>字符集Charset设置</p><ol><li><p>编码:字符串—&gt; 字节数组</p></li><li><p>解码:字节数组—&gt;字符串</p></li><li><p>用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符集编码与解码的运用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCharset</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//加载字符集的类</span></span><br><span class="line">        Charset charset = Charset.forName(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="comment">//获取编码器</span></span><br><span class="line">        CharsetEncoder charsetEncoder = charset.newEncoder();</span><br><span class="line">        <span class="comment">//获取解码器</span></span><br><span class="line">        CharsetDecoder charsetDecoder = charset.newDecoder();</span><br><span class="line">        CharBuffer charBuffer1 = CharBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        charBuffer1.put(<span class="string">&quot;oh my god ! 天哪！&quot;</span>);</span><br><span class="line">        charBuffer1.flip();</span><br><span class="line">        <span class="comment">//把字符buffer编码成字节buffer</span></span><br><span class="line">        ByteBuffer byteBuffer = charsetEncoder.encode(charBuffer1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;byteBuffer.limit();i++) &#123;</span><br><span class="line">            System.out.println(byteBuffer.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解码buffer字符串，并且输出</span></span><br><span class="line">        CharBuffer charBuffer2 = charsetDecoder.decode(byteBuffer);</span><br><span class="line">        System.out.println(charBuffer2);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        log.error(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><h4 id="缓冲区（Buffer）：负责存取"><a href="#缓冲区（Buffer）：负责存取" class="headerlink" title="缓冲区（Buffer）：负责存取"></a>缓冲区（Buffer）：负责存取</h4><ol><li><p>根据数据类型不同，有不同的缓冲区（boolean除外）：ByteBuffer、CharBuffer、ShortBuffer、LongBuffer、FloatBuffer、DoubleBuffer，都是通过<strong>allocate（int capacity）</strong>获取缓冲区</p></li><li><p>核心属性</p><ol><li><p>capacity：缓冲区最大存储数据的容量，声明后不能改变（数组初始化后大小不能改变）</p></li><li><p>limit：界限，表示缓冲区中可以操作数据的大小（limit之后的数据不能进行读写操作）</p></li><li><p>position：位置，当前缓冲区中正在操作的数据位置</p><p>规律：position&lt;=limit&lt;=capacity</p></li></ol></li><li><p>缓冲区操作方法：</p><ul><li>put():存入数据到缓冲区</li><li>flip():切换为读数据模式，此时limit变为当前position</li><li>get():获取缓冲区的数据，读取后当前position加上读取的长度</li><li>rewind():重读，让position=0,，mark=-1（<strong>取消mark标记</strong>）</li><li>clear():清空缓冲区，让缓冲区的数据处于“被遗忘”的状态（position=0、limit=capacity）</li><li>mark():标记，记录当前position的位置</li><li>reset():重置，回到最近一次mark标记的position位置</li><li>hasRemaining():缓冲区是否有剩余字符</li><li>remaining():查看当前剩余内容的字符数量</li></ul></li><li><p>直接缓冲区与非直接缓冲区</p><ul><li>直接缓冲区：通过allocateDirect()方法将缓冲区分配在<strong>直接内存（物理内存）</strong>中，提升效率</li><li>非直接缓冲区：通过allocate()方法在<strong>JVM中</strong>分配缓冲区</li></ul></li></ol></li><li><h4 id="非阻塞I-O模式与阻塞式I-O实现"><a href="#非阻塞I-O模式与阻塞式I-O实现" class="headerlink" title="非阻塞I/O模式与阻塞式I/O实现"></a>非阻塞I/O模式与阻塞式I/O实现</h4><ol><li><p>选择器(Selector)：检查一个或多个通道的状态是否可读、可写，是SelecktableChannel的多路复用器</p></li><li><p>阻塞式I/O:以下实现客户端发送图片a.png服务端接收后另存为s.png，然后告知客户端成功收到图片</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞I/O的客户端实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clientBlockingTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (SocketChannel socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9090</span>));</span><br><span class="line">         FileChannel fileChannel = FileChannel.open(Paths.get(<span class="string">&quot;a.png&quot;</span>),StandardOpenOption.READ)</span><br><span class="line">    ) &#123;</span><br><span class="line">        ByteBuffer byteBuffer =  ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">while</span> (fileChannel.read(byteBuffer) != -<span class="number">1</span>)&#123;</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            socketChannel.write(byteBuffer);</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//告知服务端客户端已经发送完毕，否则客户端会一直阻塞，此时仍能接收服务端的消息</span></span><br><span class="line">        socketChannel.shutdownOutput();</span><br><span class="line">        <span class="keyword">while</span> (socketChannel.read(byteBuffer) !=-<span class="number">1</span>)&#123;</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(byteBuffer.array(),<span class="number">0</span>,byteBuffer.limit()));</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭接收的连接</span></span><br><span class="line">        socketChannel.shutdownInput();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞I/O的服务端实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serverBlockingTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (ServerSocketChannel socketChannel = ServerSocketChannel.open();</span><br><span class="line">         FileChannel fileChannel = FileChannel.open(Paths.get(<span class="string">&quot;s.png&quot;</span>),StandardOpenOption.WRITE,StandardOpenOption.CREATE)</span><br><span class="line">    ) &#123;</span><br><span class="line">        socketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9090</span>));</span><br><span class="line">        SocketChannel acceptChannel = socketChannel.accept();</span><br><span class="line">        ByteBuffer byteBuffer =  ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">while</span> (acceptChannel.read(byteBuffer) != -<span class="number">1</span>)&#123;</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            fileChannel.write(byteBuffer);</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//告知客户端已经接收</span></span><br><span class="line">        byteBuffer.put(<span class="string">&quot;成功接收客户端发送的消息！&quot;</span>.getBytes());</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        <span class="comment">//发送回客户端</span></span><br><span class="line">        acceptChannel.write(byteBuffer);</span><br><span class="line">        acceptChannel.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>非阻塞式I/O:以下代码实现客户端向服务端发送消息，服务端输出消息，此过程是非阻塞的，即服务端接收与客户端发送后，都可以继续执行其他业务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非阻塞I/O客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (SocketChannel socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6856</span>))) &#123;</span><br><span class="line">        <span class="comment">//切换成非阻塞管道模式</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//申请缓冲区</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">//模拟用户输入</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            String next = scanner.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端发送：&quot;</span>+next);</span><br><span class="line">            byteBuffer.put((next).getBytes());</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            socketChannel.write(byteBuffer);</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非阻塞I/O服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SocketChannel socketChannel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> (ServerSocketChannel serverSocketChannel = ServerSocketChannel.open()) &#123;</span><br><span class="line">        <span class="comment">//切换成非阻塞管道模式</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">6856</span>));</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">//设置通道的选择器并且确定选择器的监听类型为连接完成</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="comment">//获取已经准备就绪的管道</span></span><br><span class="line">        <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="comment">//对于完成连接准备的管道</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">//创建与客户端的连接</span></span><br><span class="line">                    socketChannel = serverSocketChannel.accept();</span><br><span class="line">                    <span class="comment">//切换为非阻塞</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">//设置当前连接的监听器与监听的事件(读准备就绪事件)</span></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">//读准备就绪，打开管道，则进行读取</span></span><br><span class="line">                    socketChannel = (SocketChannel) key.channel();</span><br><span class="line">                    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = socketChannel.read(byteBuffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        byteBuffer.flip();</span><br><span class="line">                        System.out.println(<span class="string">&quot;服务端接收：&quot;</span>+<span class="keyword">new</span> String(byteBuffer.array(), <span class="number">0</span>, len));</span><br><span class="line">                        byteBuffer.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//删除处理完的key</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (socketChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socketChannel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>DatagramChannel：用UDP协议发送数据，多用于视频、语言等场景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void datagramClient()&#123;</span><br><span class="line">    try(DatagramChannel dc &#x3D; DatagramChannel.open())&#123;</span><br><span class="line">        dc.configureBlocking(false);</span><br><span class="line">        ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024);</span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNext())&#123;</span><br><span class="line">            String str &#x3D; scanner.next();</span><br><span class="line">            byteBuffer.put((str + LocalDateTime.now()).getBytes());</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            dc.send(byteBuffer,new InetSocketAddress(&quot;127.0.0.1&quot;,6666));</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void datagramServer()&#123;</span><br><span class="line">    try(DatagramChannel ds &#x3D; DatagramChannel.open()) &#123;</span><br><span class="line">        ds.configureBlocking(false);</span><br><span class="line">        ds.bind(new InetSocketAddress(6666));</span><br><span class="line">        Selector selector &#x3D; Selector.open();</span><br><span class="line">        ds.register(selector,SelectionKey.OP_READ);</span><br><span class="line">        &#x2F;&#x2F;通过轮询获取就绪的key</span><br><span class="line">        while (selector.select()&gt;0)&#123;</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator &#x3D; selector.selectedKeys().iterator();</span><br><span class="line">            while (iterator.hasNext())&#123;</span><br><span class="line">                SelectionKey sk &#x3D; iterator.next();</span><br><span class="line">                if(sk.isReadable())&#123;</span><br><span class="line">                    ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024);</span><br><span class="line">                    ds.receive(byteBuffer);</span><br><span class="line">                    byteBuffer.flip();</span><br><span class="line">                    System.out.println(new String(byteBuffer.array(),0,byteBuffer.limit()));</span><br><span class="line">                    byteBuffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Pipe：通过内部的source管道读取与sink管道发送数据，常用于两个线程之间单向数据交互</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在一个线程中模拟两个线程之间的通信</span></span><br><span class="line"><span class="comment"> * 首先写入一些信息，然后再让其读取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPipe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Pipe.SourceChannel source = <span class="keyword">null</span>;</span><br><span class="line">    Pipe.SinkChannel sink = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Pipe pipe = Pipe.open();</span><br><span class="line">        ByteBuffer byteBufferA = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">//A线程获取写管道</span></span><br><span class="line">        sink = pipe.sink();</span><br><span class="line">        <span class="comment">//A线程写入一些数据到缓冲区中，并且通过sink管道进行发送</span></span><br><span class="line">        byteBufferA.put(<span class="string">&quot;这是A线程写入的内容!&quot;</span>.getBytes());</span><br><span class="line">        byteBufferA.flip();</span><br><span class="line">        sink.write(byteBufferA);</span><br><span class="line">        byteBufferA.clear();</span><br><span class="line">        <span class="comment">//B线程获取读管道</span></span><br><span class="line">        source = pipe.source();</span><br><span class="line">        <span class="comment">//读取A线程的内容到B线程的缓冲区，然后输出该内容</span></span><br><span class="line">        ByteBuffer byteBufferB = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        source.read(byteBufferB);</span><br><span class="line">        byteBufferB.flip();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(byteBufferB.array(),<span class="number">0</span>,byteBufferB.limit()));</span><br><span class="line">        byteBufferB.clear();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (source != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                source.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sink != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sink.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-NIO&quot;&gt;&lt;a href=&quot;#Java-NIO&quot; class=&quot;headerlink&quot; title=&quot;Java NIO&quot;&gt;&lt;/a&gt;Java NIO&lt;/h1&gt;&lt;h3 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://b727031867.github.io/2020/10/10/Docker%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/"/>
    <id>https://b727031867.github.io/2020/10/10/Docker%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/</id>
    <published>2020-10-10T12:12:43.991Z</published>
    <updated>2020-10-05T10:31:05.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker学习笔记"><a href="#Docker学习笔记" class="headerlink" title="Docker学习笔记"></a>Docker学习笔记</h1><h2 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h2><ol><li><h3 id="Ubuntu下安装"><a href="#Ubuntu下安装" class="headerlink" title="Ubuntu下安装"></a>Ubuntu下安装</h3><ul><li>换源，换成中国科技大学的源</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">sudo sed -i &#x27;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&#x27; /etc/apt/sources.list</span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><ul><li>从Ubuntu仓库直接安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install http://docker.io</span><br></pre></td></tr></table></figure><ul><li>启动docker</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><ul><li>设置开启自启动</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure><ul><li>查看版本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure></li><li><h3 id="Windows10专业版下安装"><a href="#Windows10专业版下安装" class="headerlink" title="Windows10专业版下安装"></a>Windows10专业版下安装</h3><ul><li>控制面板-程序与功能-启用或关闭Windows功能：进行启用Hyper-V服务(开启后将无法进行虚拟化，无法使用VMware等沙盒软件)</li></ul><p><img src="/./assets/image-20200514224650672.png" alt="image-20200514224650672"></p><ul><li>打开安装包，进行安装</li><li>在settings中Shared Drives中：设置共享驱动，一般设置为项目所在盘</li><li>在settings中的advance选项中：设置虚拟机存放的路径与虚拟机的cpu、内存等</li><li>在settings中的Daemon选项中：设置镜像地址，可以设置阿里云地址进行加速</li></ul></li></ol><h2 id="安装常用镜像"><a href="#安装常用镜像" class="headerlink" title="安装常用镜像"></a>安装常用镜像</h2><ol><li><h3 id="MySQL的安装"><a href="#MySQL的安装" class="headerlink" title="MySQL的安装"></a>MySQL的安装</h3><ul><li>下载MySQL镜像8.0版本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull mysql:8.0</span><br></pre></td></tr></table></figure><ul><li>创建需要挂载的文件夹与配置文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo  mkdir /home/root/mysql;</span><br><span class="line">cd /home/root/mysql;</span><br><span class="line">sudo mkdir data;</span><br><span class="line">sudo mkdir config;</span><br><span class="line">sudo cd config;</span><br><span class="line">sudo  touch my.cnf;</span><br><span class="line">sudo  vim my.cnf;</span><br></pre></td></tr></table></figure><p>写入的my.cnf 文件内容，用于自定义mysql的配置信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">user&#x3D;mysql</span><br><span class="line">character-set-server&#x3D;utf8mb4</span><br><span class="line">#设置密码验证插件</span><br><span class="line">default_authentication_plugin&#x3D;mysql_native_password</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">default-character-set&#x3D;utf8mb4</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set&#x3D;utf8mb4</span><br></pre></td></tr></table></figure><ul><li>linux运行mysql，设置容器名称为mysql、设置mysql的持久化目录与配置文件的宿主目录、mysql连接密码，使用host模式则不虚拟网络，直接使用宿主机的网络</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --name mysql --restart always --privileged=true -p 3306:3306 \</span><br><span class="line">-v /home/root/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /home/root/mysql/config/my.cnf:/etc/my.cnf \</span><br><span class="line">-e MYSQL_USER=&quot;root&quot; -e MYSQL_PASSWORD=&quot;root&quot; \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=&quot;root&quot; -d mysql:8.0</span><br></pre></td></tr></table></figure><ul><li>win10下运行：不使用宿主机网络，则需要设置端口映射</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -<span class="literal">-name</span> mysql -<span class="literal">-restart</span> always -<span class="literal">-privileged</span>=true <span class="literal">-p</span> <span class="number">3306</span>:<span class="number">3306</span> `</span><br><span class="line"><span class="literal">-v</span> <span class="built_in">H</span>:/DockerFiles/mysql/<span class="keyword">data</span>:/var/lib/mysql `</span><br><span class="line"><span class="literal">-v</span> <span class="built_in">H</span>:/DockerFiles/mysql/config/my.cnf:/etc/my.cnf `</span><br><span class="line"><span class="literal">-e</span> MYSQL_USER=<span class="string">&quot;root&quot;</span> <span class="literal">-e</span> MYSQL_PASSWORD=<span class="string">&quot;root&quot;</span> `</span><br><span class="line"><span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="string">&quot;root&quot;</span> <span class="literal">-d</span> mysql:<span class="number">5.7</span></span><br></pre></td></tr></table></figure></li><li><h3 id="Redis的安装"><a href="#Redis的安装" class="headerlink" title="Redis的安装"></a>Redis的安装</h3><ul><li>获取镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis:5.0.9</span><br></pre></td></tr></table></figure><ul><li>创建数据与配置文件的存放目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/root/redis;</span><br><span class="line">cd /home/root/redis;</span><br><span class="line">mkdir data;</span><br><span class="line">mkdir conf;</span><br><span class="line">cd conf;</span><br><span class="line">touch redis.conf;</span><br><span class="line">vim redis.conf;</span><br></pre></td></tr></table></figure><ul><li><p>将官方对应版本的redis.conf文件的内容粘贴进去，并且修改以下部分</p><ol><li>bind 127.0.0.1 改为 #bind 127.0.0.1 关闭限制redis只能本地访问</li><li>protected-mode  yes 修改为 protected-mode no 关闭限制本地访问</li><li>appendonly no 修改为 appendonly yes （可选）  开启追加日志</li><li>requirepass 123GONG123 #连接的密码</li></ol></li><li><p>启动redis， redis-server /etc/redis/redis.conf 表示使用宿主机挂载的配置文件启动</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --name redis5.0.9 --restart always -d -p 6379:6379 --privileged=true \</span><br><span class="line">   -v /home/root/redis/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-v /home/root/redis/data:/data \S</span><br><span class="line">   redis-server /etc/redis/redis.conf --appendonly yes</span><br></pre></td></tr></table></figure></li><li><h3 id="Java容器的安装及部署项目"><a href="#Java容器的安装及部署项目" class="headerlink" title="Java容器的安装及部署项目"></a>Java容器的安装及部署项目</h3><ul><li>获取java镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull java:8-jdk-alpine</span><br></pre></td></tr></table></figure><ul><li>打包项目，使用maven进行打包，并且<strong>跳过测试</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">到项目根目录下执行打包命令</span></span><br><span class="line">mvn package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure><ul><li>部署项目</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/root/project//创建部署项目的目录</span><br><span class="line">cd /home/root/project</span><br><span class="line">//上传jar包到当前目录下</span><br><span class="line">touch Dockerfile//创建docker配置文件</span><br><span class="line">vim Dockerfile</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###文件填入以下内容</span></span></span><br><span class="line">FROM java:8-jdk-alpine</span><br><span class="line">LABEL maintainer=&quot;www.gxf727031867.top&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">JAR_FILE参数替换成jar包全称!</span></span><br><span class="line">ARG JAR_FILE=HIS-0.0.1-SNAPSHOT.jar</span><br><span class="line"><span class="meta">#</span><span class="bash">挂载系统日志</span></span><br><span class="line">VOLUME /home/root/project/Logs:/Logs</span><br><span class="line">ADD $&#123;JAR_FILE&#125; app.jar</span><br><span class="line">EXPOSE 8081</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###构建镜像，-t指定镜像名称，注意最后有一个点</span></span></span><br><span class="line">sudo docker build -t his .</span><br><span class="line">sudo docker images//查看生成的镜像</span><br><span class="line">docker image prune//删除虚悬镜像，即REPOSITORY为none的镜像</span><br><span class="line"><span class="meta">#</span><span class="bash">运行项目，并且配置挂载日志的目录，注意最后的镜像名称为上文中的his,配置app连接到mysql网络中</span></span><br><span class="line">docker run --network=host -d --privileged=true   \</span><br><span class="line">-v /home/root/project/Logs:/Logs --name app his:latest</span><br></pre></td></tr></table></figure></li><li><h3 id="Nginx容器的安装及部署项目"><a href="#Nginx容器的安装及部署项目" class="headerlink" title="Nginx容器的安装及部署项目"></a>Nginx容器的安装及部署项目</h3><ol><li><ul><li>获取nginx镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull nginx</span><br></pre></td></tr></table></figure><ul><li>创建用户端目录与管理端目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">本地打包web项目</span></span><br><span class="line">npm run build</span><br><span class="line"><span class="meta">#</span><span class="bash">服务器端创建nginx的配置目录、默认配置目录、项目存放目录、日志存放目录</span></span><br><span class="line">mkdir /home/root/nginx/conf</span><br><span class="line">mkdir /home/root/nginx/conf.d</span><br><span class="line">mkdir /home/root/nginx/html</span><br><span class="line">mkdir /home/root/nginx/logs</span><br><span class="line">cd /home/root/nginx</span><br></pre></td></tr></table></figure><ul><li><strong>上传打包后dist文件夹下的内容到html目录下</strong>，其中包含的目录结构如下，客户端dist中的内容上传到client中，后端管理系统dist中的内容上传到admin中。打包vue项目的时，<u>需要在vue.config.js中设置<strong>publicPath: ‘/admin/‘**与</strong>publicPath: ‘/client/‘**防止静态资源路径错误</u></li></ul></li></ol><p><img src="/assets/image-20200519135229739.png" alt="image-20200519135229739"></p><ul><li><p>获取nginx的配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">   #</span><span class="bash">运行nginx</span></span><br><span class="line">   docker run -d -p 80:80 --name mynginx nginx</span><br><span class="line"><span class="meta">   #</span><span class="bash">复制容器中的配置文件到宿主机中</span></span><br><span class="line">   docker cp mynginx:/etc/nginx/nginx.conf /home/root/nginx/conf/nginx.conf</span><br><span class="line">   docker cp mynginx:/etc/nginx/conf.d/default.conf /home/root/nginx/conf.d/default.conf</span><br><span class="line"><span class="meta">   #</span><span class="bash">关闭并且删除当前容器</span></span><br><span class="line">docker stop mynginx</span><br><span class="line">   docker rm mynginx</span><br></pre></td></tr></table></figure></li><li><p>首先确保域名绑定了服务器的IP</p></li><li><p>下载证书申请脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.eff.org/certbot-auto</span><br><span class="line">chmod 775 certbot-auto</span><br></pre></td></tr></table></figure></li><li><p>进行申请，-d表示为多个域名申请，*表示通配符。如果只有一个域名，则只用一次-d。运行后会询问是否同意使用条款，选择A；是否公开邮箱，选择Y、是否公开IP记录，选择Y。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./certbot-auto certonly  -d mysite.gxf727031867.top \</span><br><span class="line">--manual --email 1085386394@qq.com \</span><br><span class="line">--preferred-challenges dns --server https://acme-v02.api.letsencrypt.org/directory</span><br></pre></td></tr></table></figure></li><li><p>前往域名解析处设置DNS记录。脚本运行完毕后会得到<strong>主机记录</strong>与<strong>记录值</strong></p><p><img src="/assets/image-20200519133354713.png" alt="image-20200519133354713"></p></li><li><p>设置对应的值，以阿里云为例</p><p><img src="/assets/image-20200519135734392.png"></p></li><li><p>可以前往<a href="http://dbcha.com/%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E6%88%90%E5%8A%9F%E8%A7%A3%E6%9E%90">http://dbcha.com/检查是否成功解析</a></p></li><li><p>成功解析后，回到控制台按下<strong>回车</strong>继续申请</p><p><img src="/assets/image-20200519134041901.png" alt="image-20200519134041901"></p></li><li><p>申请完成后，证书的目录位于**/etc/letsencrypt/live/[域名]**目录下<br>其中 fullchain.pem文件是完整的证书链      privkey.pem文件是证书私钥</p><p><img src="/assets/image-20200519134143282.png" alt="image-20200519134143282"></p></li><li><p>证书有效期为三个月，续签需要使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./certbot-auto renew</span><br></pre></td></tr></table></figure></li><li><p>配置nginx的配置文件，实现同一个域名下部署两个vue项目以及https访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn;</span><br><span class="line">pid        &#x2F;var&#x2F;run&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       &#x2F;etc&#x2F;nginx&#x2F;mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    gzip  on;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">    listen       80 ;</span><br><span class="line">    listen       [::]:80 ;</span><br><span class="line">    server_name mysite.gxf727031867.top;</span><br><span class="line"></span><br><span class="line">    if ($host &#x3D; mysite.gxf727031867.top) &#123;</span><br><span class="line">        return 301 https:&#x2F;&#x2F;$host$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 404;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">    listen 443 ssl http2;</span><br><span class="line">    server_name mysite.gxf727031867.top;</span><br><span class="line">    ssl_certificate   cert&#x2F;live&#x2F;mysite.gxf727031867.top&#x2F;cert.pem;</span><br><span class="line">    ssl_certificate_key cert&#x2F;live&#x2F;mysite.gxf727031867.top&#x2F;privkey.pem;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">      location &#x2F; &#123;</span><br><span class="line">                 root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;client;</span><br><span class="line">                 index index.html index.htm;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      location  &#x2F;admin &#123;</span><br><span class="line">                 alias &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;admin&#x2F;;</span><br><span class="line">                 index index.html;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    #include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br></pre></td></tr></table></figure></li><li><p>运行nginx并且挂载目录，包括配置与默认配置与日志与证书文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --network=host --privileged=true --name nginx -d \</span><br><span class="line">-v  /home/root/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-v  /home/root/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v  /home/root/nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf \</span><br><span class="line">-v  /etc/letsencrypt:/etc/nginx/cert \</span><br><span class="line">-v  /home/root/nginx/logs:/var/log/nginx nginx</span><br></pre></td></tr></table></figure></li></ul></li><li><h3 id="MiniO安装"><a href="#MiniO安装" class="headerlink" title="MiniO安装"></a>MiniO安装</h3><ul><li><p>拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull minio/minio</span><br></pre></td></tr></table></figure></li><li><p>映射端口，与持久化目录，启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 9000:9000 --privileged=true --restart always -d --name minio \</span><br><span class="line">  -e &quot;MINIO_ACCESS_KEY=AKIAIOSFODNasdE&quot; \</span><br><span class="line">  -e &quot;MINIO_SECRET_KEY=wJalrXUtnFEMI/K7MDasdEXAMPLEKEY&quot; \</span><br><span class="line">  -v /mnt/data:/data \</span><br><span class="line">  -v /mnt/config:/root/.minio \</span><br><span class="line">  minio/minio server /data</span><br></pre></td></tr></table></figure></li><li><p>访问127.0.0.1:9000即可</p></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker学习笔记&quot;&gt;&lt;a href=&quot;#Docker学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Docker学习笔记&quot;&gt;&lt;/a&gt;Docker学习笔记&lt;/h1&gt;&lt;h2 id=&quot;Docker的安装&quot;&gt;&lt;a href=&quot;#Docker的安装&quot; c</summary>
      
    
    
    
    
  </entry>
  
</feed>
