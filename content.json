{"meta":{"title":"一叶知秋","subtitle":"大道至简，知易行难，知行合一，得到功成","description":"本博客主要用于记录、分享编程之路遇到的那些事儿~","author":"Mr.G","url":"https://b727031867.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-10-10T14:59:34.000Z","updated":"2020-10-11T01:15:24.562Z","comments":false,"path":"categories/index.html","permalink":"https://b727031867.github.io/categories/index.html","excerpt":"","text":""},{"title":"repositories","date":"2020-10-10T15:03:30.000Z","updated":"2020-10-11T01:15:27.988Z","comments":false,"path":"repositories/index.html","permalink":"https://b727031867.github.io/repositories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-10-10T14:59:56.000Z","updated":"2020-10-11T01:15:18.093Z","comments":false,"path":"tags/index.html","permalink":"https://b727031867.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"设计模式","slug":"设计模式","date":"2020-10-10T15:57:08.000Z","updated":"2020-10-10T15:16:43.166Z","comments":true,"path":"2020/10/10/设计模式/","link":"","permalink":"https://b727031867.github.io/2020/10/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式学习笔记 七大设计原则 单一职责原则：一个类只负责一项职责作用：防止修改代码时，影响其他功能，降低类之间的耦合 注意：逻辑简单，可以违背类级别的单一职责，即一个类包含多个功能，但是，最低要保证方法的职责单一 接口隔离原则：类只依赖所需的最小接口作用：避免实现自身用不到的方法、降低耦合，提高代码阅读性 特点：把通用的方法抽取到更小的接口中，类实现多个小接口来满足自身的需要 依赖倒置（倒转）原则：抽象不依赖细节，细节依赖抽象作用：让代码更加稳定，减少修改的可能性（抽象层较为稳定）；通过接口与抽象类编写规范，交给实现类完成功能。 特点：面向接口编程，通过传递接口参数，根据具体实现类的不同而完成不同的功能。相当于通过接口进行耦合，避免了类与类之间的强耦合。 里氏替换原则：能用父类的位置都能用子类替换作用：减少继承的使用，通过聚合、组合、依赖三种类的关系来取代继承；防止子类无意中重写父类方法，而导致程序出错（如果子类重写了父类方法，将调用子类的实现方法，可能导致与原来不同的结果） 特点：子类尽量不重写父类方法，运用父类的位置可以替换成子类。 开闭原则：对扩展开放，对修改关闭作用：能够避免修改代码，灵活扩充功能（是使用设计模式的最终目标，上述原则作为此原则的铺垫） 特点：使用（调用）方无需修改代码，提供方可以通过添加抽象方法直接添加功能（由子类实现功能） 迪米特原则（最小知道原则）：类对依赖的类知道的越少越好作用：降低类之间的耦合 特点：只和直接关联的类通信，类自身的逻辑应该由自身内部完成，对外只提供公开方法 直接关联的类：成员方法、方法参数、返回值用到的类（局部变量使用的类不属于） 合成复用原则：少用继承，多用组合、聚合代替继承特点：通过少用继承，多用依赖的方式降低类之间的耦合度 UML 作用：统一建模语言，用于描述软件模型中各个元素之间的关系 分类 动态图： 序列图 协作图 状态图 活动图 静态图： 用例图 类图 对象图 包图 构件图 部署图 类关系 依赖关系：类中使用了其他类（范围最大），则它们存在依赖关系 关联关系：具有方向性，用于表示对象间的数量关系（1：1、1：n、n：n） 聚合关系：整体与部分可以分割（例如：你与你的电脑，电脑可有可无） 组合关系：整体与部分不可分割——同生共死（比如脸上含有眼睛、嘴巴等） 泛化关系：依赖关系的特例，表示继承关系 实现关系：依赖关系的特例，表示它与它实现接口的关系 23种设计模式 创建型：用于对象创建管理 单例模式作用：确保重量级对象只返回一个实例，避免资源浪费、并发问题；对于频繁创建与销毁对象的情况，可以提高性能 常见写法： 饿汉式 静态常量饿汉式实现： 优点：实现简洁，通过类装载机制保证线程安全 缺点：无法懒加载，可能浪费内存 实现步骤： 构造方法私有 静态成员变量new自身（无法懒加载） 提供公有静态方法获取成员实例 静态代码块饿汉式实现 只是把上述new的过程放入静态代码块实现，优缺点、步骤同上 懒汉式 线程不安全懒汉式实现 优点：懒加载 缺点：线程不安全（不建议使用） 实现步骤 构造器私有 定义静态实例变量 在返回实例方法中初始化静态实例变量 线程安全（同步方法）懒汉式实现 优点：线程安全 缺点：同步整个方法的性能不高（每次返回实例都需要同步） 实现步骤：根据上述步骤，在返回实例的方法上添加同步关键字 同步代码块懒汉式实现 优点：效率比同步方法高 缺点：线程不安全（不能使用） 实现步骤：根据上述步骤，改为同步代码块实现返回实例的方法 双重校验实现 优点：懒加载、线程安全、性能高 缺点：JDK5之前的内存模型存在缺陷，无法使用volatile关键字完全避免指令重排序 实现步骤 构造器私有，同上 声明静态成员变量，并且添加volatile关键字修饰 获取实例的方法进行双重检查 静态内部类实现 优点：线程安全、懒加载（通过JVM静态内部类装载机制保证线程安全与懒加载） 缺点：无法防止反序列化创建对象 实现步骤 构造器私有，同上 写一个静态内部类，定义并且初始化实例变量 调用静态内部类的实例变量获取实例 枚举实现 优点：线程安全、防止反序列化创建对象、实现简单 缺点：不能懒加载 实现步骤 定义枚举 添加单例属性与自己的方法 简单（静态）工厂模式 优点：实现创建对象和使用分离（与客户端解耦） 缺点： 工厂类违反单一职责，负担过重 违反开闭原则，扩展复杂，需要修改代码 作用：封装创建多种对象、某一类对象的行为，避免添加新的产品类型而改动大量代码 类图：简单工厂持有抽象产品的引用，根据传入的产品类型选择实例化对象。 其他：不推荐使用，除非产品与工厂都十分简单 常见写法： 定义各类产品的抽象类 定义具体的产品类，并且继承其抽象类 定义工厂类 在构造方法中传入具体产品类型 根据产品类型new实例对象并且返回其抽象类型 需要生产产品的类中，通过聚合或者组合引用工厂对象，调用创建方法创建产品 工厂方法模式 优点： 能对客户端隐藏实现细节（最小知道（迪米特）原则） 允许抽象工厂通过多态（继承）灵活创建不同的对象，每种具体工厂负责单一产品（单一职责原则） 添加工厂与产品无需修改客户端、无需修改其他具体工厂和具体产品（开闭原则） 缺点： 抽象度高，理解与使用较难 类的数量很多，导致系统复杂，并且需要额外开销 作用：解决多种工厂导致类数量过多、将实例化的过程推迟到子类中，符合开闭原则。 类图：产品与工厂都是抽象类，它们都能扩展自己的子类。工厂依赖抽象产品；具体的工厂实现生产具体产品的方法，并且它依赖于具体的产品 其他：多种工厂对应多种产品的情况常见于针对特定类型的产品，添加特定的生产工厂。例如生产中国菜和日本菜，材料不同，菜式不同、厨房也不同，但是厨房生产菜的抽象是不变的，因此需要生产额外地区的菜，只需要添加新的菜式和厨房即可。比如新添加泰国菜和泰国厨房。如果结合简单工厂可以让中国厨房生产粤菜、湘菜，实现一个具体的工厂生产多种具体的产品，但是这样就违背了开闭原则，可以通过抽象工厂实现而不违背开闭原则。 常见写法： 创建抽象工厂类，定义工厂的生产方法 创建抽象产品类，定义抽象产品方法 创建具体产品类，继承抽象产品类，实现产品的抽象方法 创建具体工厂类，继承抽象工厂类，实现生产的抽象方法 调用方通过调用具体工厂类，产生不同的具体产品 抽象工厂模式 优点： 对客户端隔离了类的生成（最小知道（迪米特）原则） 增加产品族（某种品牌的工厂）时，符合开闭原则 对需要使用同一产品族（同一个品牌）的情况有利（例如：组装电脑的所有配件都选用英特尔，而不是CPU选英特尔，显卡选英伟达） 缺点：由于开闭原则具有倾斜性（会让某一方更加容易开闭），增加新的产品等级（新产品），会导致所有具体工厂都需要添加新产品的生产方法，违背了开闭原则 作用：用于产品等级结构稳定，产品族变动的情况。（生产产品的种类固定，但是品牌不同） 类图： 其他：抽象工厂最好用于产品种类固定的情况 原型模式 优点：简化创建过程（避免反复Get与Set被复制对象的值） 缺点：通过重写克隆方法实现原型模式，不符合开闭原则 作用：灵活的克隆简单对象 类图： 实现方法： 自己定义一个抽象原型类，包含一个抽象的克隆方法，需要克隆的类继承该类并且实现克隆方法。在方法中创建一个新对象，并且把属性值都重新赋值到新对象上，最后返回新对象 通过实现Cloneable接口并且重写Object类中的clone方法。在方法中调用super.clone()，最终强转回具体的对象返回 浅拷贝 特点：复制基础类型的值，无法复制引用对象，引用对象只复制引用值（指针） 实现方法：同上 深拷贝 特点：复制所有属性，包含引用对象 实现方法： 上述使用super.clone()方法只能浅拷贝，需要自己手动复制引用对象，通过引用对象也实现clone方法，调用引用对象的clone方法，返回引用对象，再赋值到当前要深拷贝的对象中，最后返回深拷贝对象 使用序列化。首先，对象必须实现Serializable接口，然后通过序列化与反序列化进行深拷贝 原型管理器：将多种原型（需要克隆的）对象用哈希表进行管理，相当于克隆对象的工厂，便于扩展原型对象，类图如下： 建造者模式 优点： 分离复杂对象的创建流程，让对象与对象的创建过程解耦 能用相同的创建流程创建不同的对象，精细的控制创建复杂对象的过程 通过抽象建造者充当缓冲层，具体建造者之间相互隔离，便于替换或添加新的具体建造者，符合开闭原则 缺点： 对于产品之间差异过大的情况，不适合使用，适用范围受限 对于产品内部复杂、细微差异过多的情况，会导致具体建造者过多，不利于维护与阅读 作用：将复杂对象与它的构建分离，让同样的构建过程创建不同的对象 类图： 抽象建造者（Builder）：负责规定返回产品的方法、创建产品部件包含的方法 具体建造者（ConcreteBuilder）：实现创建产品部件的方法，定义部件的装配过程，可有选择的重写返回产品的方法 产品（Product）：被构建的复杂对象，包含多个部件。 指挥者（Director）：在construct方法中定义不同部件（属性）的建造次序（例如盖房子，顺序为先打地基，再砌墙，最后盖屋顶），可以定义多个construct来控制组件的建造顺序（变为先砌墙，再打地基，最后盖屋顶），最后返回构建完毕的产品。如果对象组装简单，可以省略指挥者类，将构造方法置于抽象建造者中；如果对象组装复杂，可以用钩子函数决定是否组装某些组件（类似于模板方法模式） 使用场景： 产品之间相似度高（例如配件相似、组装流程相似） 产品的创建十分复杂，需要自由控制创建流程 希望产品的创建过程独立于创建该对象的类、用相同的创建过程创建不同的产品 实现方法： 编写产品类，确定产品具有哪些组件（属性） 编写抽象建造者，初始化一个产品对象成员变量，定义产品相似的部分、定义返回产品的方法 编写具体建造者，创建并且设置产品成员变量的属性（例如：产品成员变量是车，包含发动机、轮胎，此处确定产品具体的部分使用什么组件，使用大马力发动机与防滑轮胎）、实现返回产品（可选） 编写指挥者类，通过construct方法，根据不同的具体建造者，确定产品的装配流程（确定是先组装轮胎还是先组装发动机），返回产品 编写客户端，定义具体的建造者与指挥者，传入具体建造者的类型给指挥者，然后调用指挥者的construct方法生产产品 结构型：让类或对象之间组织成更加灵活、强大的结构 适配器模式名词解释：目标类——客户端需要用的接口或方法（想要通过调用已有接口或方法来实现的接口或者方法）、适配者——被适配的类（已完成的接口或方法） 优点： 通过适配与兼容来重用某些已有的接口，提高了代码的复用性 将目标类与适配者分离，降低了代码耦合热望 添加适配器类时，符合开闭原则 对于对象适配器，可以适配多个适配者（持有多个适配者的成员变量）；根据里氏替换原则，可以适配适配者（被适配的类）的子类 缺点： 适配者类不能为final类 对于类适配器，Java等单继承的语言， 一次只能适配一个适配者 目标类只能为接口，有一定的局限性 对于对象适配器，修改适配者的方法复杂（可以通过实现一个适配者的子类，修改方法后，替换适配器中持有的成员变量为该子类对象） 作用：通过适配器来兼容不同的接口，使得它们能协同工作 适配器分类 类适配器：继承适配者，实现目标类中需要的方法或者接口 对象适配器：依赖适配者（适配器类中持有适配者成员变量），继承或者实现目标类 单接口（缺省）适配器：通过抽象类空（默认）实现接口中的方法，子类可以有选择的重写这些空方法 双向适配器：在对象适配器中，持有目标类与适配者的成员变量 使用场景： 已有的接口和想要的新接口功能几乎相同，只是规格不同（比如换算单位不一样，电压标准不同等等） 创建可重复使用的类，这个类作为那些没有太大关联的类（包括以后要添加的类）的桥梁 桥接模式 优点： 分离抽象接口与实现部分。通过关联关系代替继承关系，让抽象和实现能够根据各自的维度独立变化，由不同维度组合出不同功能的对象 减少了继承层级，减少了子类数量 扩展不同维度中独立变化的部分，只需要添加对应维度的子类即可，符合开闭原则 缺点： 正确的识别类的不同维度的变化比较困难，需要十分有经验 需要在设计阶段就进行抽象分析，增加了系统的设计与理解难度 作用：将抽象部分与它的实现部分解耦，让两者能够独立变化 类图： 使用场景： 避免不同维度的变化通过静态的继承关系实现，想要在抽象层建立中关联关系 系统希望对抽象角色与具体角色动态耦合（即将抽象对象的子类与实现对象的子类通过关联关系进行动态组合） 一个类存在多种独立变化的维度，并且每种维度都希望能够独立扩展 对于使用多层继承会造成类数量的过多的系统 编写步骤： 编写抽象类，通过构造方法注入具体实现接口的成员变量，并且在抽象类中定义抽象方法 编写具体实现接口，定义（需要独立变化与扩展的）业务方法 编写具体实现接口的实现类，实现上述的业务方法 编写细化（扩展）抽象子类，实现抽象类中定义的抽象方法。此时，可以调用父类中具体实现接口的成员变量中的方法，完成对不同维度功能的组合 编写客户端，定义抽象引用和具体实现接口引用，创建不同的抽象细化类与具体接口实现类，将具体接口实现类Set到抽象细化类中，便可以组合出具有不同功能的对象 装饰模式 优点： 扩展对象的功能比继承更加灵活，减少了继承层次，不会导致类爆炸 能够动态扩展对象的功能，实现不同行为（例如：读取配置文件，选择不同的具体装饰类） 对透明装饰模式，可以多次装饰某个对象，排列组合得到不同行为与功能的对象 具体组件类与具体装饰类互相独立，符合开闭原则 缺点： 因为不同的修饰方式可以产生功能不同的对象，所以会导致系统存在很多小对象，它们的区别仅仅是组合、连接的方式不同，不是类或者属性的不同，小对象过多会影响系统性能 对于被多次装饰的对象，不利于排查错误 作用：动态的给某个对象添加额外的职责，提供比继承更加灵活的扩展方式 分类： 透明装饰模式： 客户端全部使用抽象组件接收实例化的部分 可以对组件多次装饰（因为都是抽象组件的子类，并且通过构造方法实例化抽象组件成员变量） 客户端没办法调用具体装饰器中新增的方法（因为抽象组件中没有定义这些方法） 半透明装饰模式： 客户端可以使用抽象组件接收具体组件，但是只能用具体装饰器引用接收具体装饰器的实例，从而能够调用具体装饰器中的新增方法 不能多次装饰具体组件，只能装饰一次 类图：图中为透明装饰模式，若为半透明装饰模式，则具体组件只能被装饰一次，并且可以单独调用被添加（用于装饰对象）的方法 使用场景： 不影响其他对象实例，只想对某个对象实例动态、透明的添加职责 无法使用继承或继承不利于系统维护与扩展时，可以通过装饰模式来扩展功能（例如：Java中的final类、继承层次过多等） 编写方法： 编写抽象组件类，定义抽象方法（需要被修饰、增强的方法） 编写具体组件类，继承抽象组件类 编写装饰类，继承抽象组件类，在类中添加抽象组件的成员变量，通过构造器实例化抽象组件的成员变量 在装饰类中，重写抽象方法时，调用成员变量的抽象方法 编写具体装饰类，继承装饰类，构造方法调用中调用装饰类的构造方法，传入抽象组件对象 在具体装饰类中，重写抽象方法时，调用成员变量的抽象方法（原本的业务方法），调用自身新增的业务方法 编写客户端类，创建具体组件对象，传入具体装饰对象的构造方法中， 若为透明装饰模式，则可以都用抽象组件引用接收对象并使用，并且可以多次装饰，没有办法调用被装饰后新增的业务方法 若为半透明装饰模式，则定义具体组件可以用抽象组件的引用接收，被装饰的对象只能用具体装饰器接收，此时可以调用具体装饰对象的新增业务方法 组合模式 优点： 能够清楚地定义层次关系，客户端可以忽略层次的不同进行操作 透明组合模式下，由于客户端能够一致的使用叶子构件和容器构件的方法，所以能简化调用代码 添加叶子构件或者容器构件都十分方便，无需改动现有代码，符合开闭原则 不仅对树形结构的控制简单，而且能够通过叶子构件与容器构件递归组合，实现复杂的树形结构 缺点： 添加新的构件类型，容易产生过多的类 如果希望某个容器下只允许某种叶子构件，需要编写代码约束，十分复杂（不然客户端给A容器添加C容器的C叶子节点，而本来A容器应该添加A叶子节点） 作用：组合多种对象，形成树形结构，表示部分-整体的层次结构。组合模式能统一操作叶子节点与父节点，无需关心它们的区别 分类： 透明组合模式：调用叶子构件与容器构件都一样，但是调用叶子构件会产生异常，没有进行处理会出错 安全组合模式：抽象构件中不提供操作子节点的方式，这样客户端无法统一对叶子构件和容器构件编程，不会出现抛不支持操作异常的情况 类图： AbstracComponent：抽象构件，可以是抽象类或者接口，为叶子节点（叶子构件）与父节点（容器构件）声明通用操作的接口 Composite：容器构件，实现抽象构件中的接口，使用集合存储它所管理的叶子节点列表，并且可以递归调用子节点的方法，直到调用时遇到叶子节点为止 Leaf：叶子构件，它没有子节点，实现抽象构件中的部分接口，如果调用了它未实现的操作方法，则可以抛出异常（例如：调用叶子节点增加子节点的方法，可以抛出不支持该操作的异常） 使用场景： 具有部分与整体的层次结构，并且希望客户端统一管理部分与整体 希望在面向对象语言中处理树形结构，并且节点具有相似的方法 系统可以分离出叶子构件与容器构件，并且它们的类型数量不确定，希望随时扩充新类型(Swing包中的Panel(容器)和Button(叶子)等GUI编程) 编写方法： 编写抽象构件类：定义通用的子节点管理抽象方法(增删改查子节点)，定义需要实现的抽象业务方法 编写容器构件类：继承或者实现抽象构件中的方法，编写一个抽象构件集合，用于存储当前容器所管理的子构件列表 编写叶子构件类：继承或实现抽象构件中的方法 编写客户端，定义抽象构件的引用，实例化容器构件与叶子构件，将叶子构件添加到容器构件中，再调用容器构件的业务方法 外观模式 优点： 子系统内部的变化不影响外观对象 客户端只需要依赖外观对象，不需要关联子系统的各种对象，降低了耦合，让子系统更加容易使用 子系统内部的变化不影响客户端对其使用 缺点： 客户端可能绕过门面类直接访问子系统，想要避免这种情况会减低子系统的灵活性与可变性 如果门面类设计有缺陷，后期新增子系统或者新增门面功能会导致门面类代码变动，不符合开闭原则 作用：作为子系统接口调用的统一入口，方便使用子系统 类图： 使用场景： 为客户端提供多种复杂子系统的统一API调用入口 客户端与子系统的耦合很强，通过引入外观类进行解耦 在多层结构中，通过外观类定义每层的入口，由外观类进行层与层之间的通信，降低了层之间的耦合度 编写方法： 编写抽象外观类，定义通用的抽象方法 编写子系统类（单例类、工厂类等），实现该子系统负责模块的方法 编写具体外观类继承抽象外观类，定义具体外观类中需要用到的子系统成员变量，调用并且组合子系统中的模块方法实现父类的抽象方法 创建客户端类，定义抽象门面类的引用，实例化具体门面类，调用通用的抽象方法 享元模式 优点： 重复利用（相同或相似的）细粒度对象，节省系统资源 区分了对象的外部状态与内部状态，它们相互独立，使得具有不同外部状态的对象可以共享相同的内部状态对象（例如：棋子的位置对象[外部状态]与黑色或白色棋子对象[内部状态]，可以通过设置不同的位置坐标，传入黑棋或者白棋，黑棋或白棋对象则只会产生一个） 缺点： 分离了内部状态与外部状态，使得对象变得复杂，对对象的操作也会复杂 由于分离了内部与外部状态，那么读取这个对象对应的外部状态需要耗费更长的时间 作用：运用共享技术复用大量细粒度的对象 类图：使用单例模式创建共享的享元对象以及享元工厂；使用组合模式组合共享的享元对象与不共享的享元对象；使用享元模式对共享的对象进行缓存，而不是重复创建（此图为复合享元模式的类图） 分类 单纯享元模式：只存在可以共享的享元类，没有不可共享的享元类，即只有上图的ConcreteFlyweight类、AbstractFlyweight类、FlyweightFactory类 复合享元模式：使用组合模式组合了不可共享的类 使用场景： 系统中存在大量相同或者相似的对象 某种对象的大部分状态可以分为不变与变化的，将变化的状态封装成不共享的对象，不变的状态进行缓存 由于使用缓存池缓存享元对象，会耗费系统资源，所以享元对象应该被频繁使用，避免浪费资源 代理模式 优点： 通过代理对象协调调用者与被调用者，降低了它们之间的耦合度 客户端使用代理对象进行编程，所以修改被代理对象的代码时，客户端无需修改代码，符合开闭原则 使用远程代理时，可以将运算复杂的业务放置在高性能服务器中，提升了系统整体的运行效率 使用虚拟代理时，可以懒加载某些需要庞大性能的对象，节省了系统资源 使用缓冲代理时，可以对运算结果进行临时缓存，共享给后续运算步骤，优化了系统性能 使用保护代理时，可以控制对象的访问权限，给不同的客户端分配不同的使用权限 缺点： 由于多了代理层，可能会造成业务处理速度降低（例如：保护代理，需要进行权限检查，而权限检查需要耗费系统资源） 某些代理模式的实现方式十分复杂（例如：Java中的RMI（远程代理），需要序列化对象，反序列化对象等一系列操作） 作用：提供某个对象的代理对象，由代理对象来控制对原来对象的访问 分类： 远程代理：使得客户端能使用远程服务器中的方法 虚拟代理：对加载时间长的对象，先使用“虚假”的代理对象来代表真实对象，等真实对象加载完毕后，虚拟代理将请求转发给真实对象 静态代理：代理类和被代理类都必须继承或实现相同的父类或接口，代理类持有被代理类的成员变量，并且重写父类方法，调用被代理类中相同的方法（这样会导致代理类的数量过多） JDK动态代理：能够在系统运行时，根据需要动态的创建代理类，使得同一个代理类能代理多个不同的被代理类，常用于事务管理、AOP编程等（被代理的对象必须实现或继承它原本的父类或接口） CGLIB(Code Generation Library)动态代理：与JDK动态代理相比，被代理的类也不需要实现接口或者继承父类 保护代理：对于某些敏感的对象，在调用前，代理对象会检查客户是否具有权限，没有权限则不允许调用 缓冲代理：对于计算量较大的对象，通过在客户端或者服务端创建缓冲代理对象，避免每次调用都进行重复计算 智能引用代理：代理对象内部计数器计算调用次数，当没有使用者调用时，则该自动释放该代理对象 类图：下图为静态代理模式的类图，代理对象与被代理对象都必须实现相同的接口，代理对象可以在调用被代理对象方法的时候，进行一些额外的操作 使用场景： 客户都安需要访问远程服务器中的对象，可以使用远程代理 可以通过虚拟代理缩短系统的启动时间 对频繁访问的计算结果，使用缓冲代理进行缓存 需要对调用方进行权限控制，可以使用保护代理 需要为某个对象的引用提供额外功能时，可以使用智能引用代理（例如：某个对象的引用次数为0，则可以释放该对象） 行为型：关注方法层面的调用 模板方法模式 优点： 抽象出公共步骤，复用了代码 子类实现具体的细节，便于替换与扩展算法实现 类的行为由父类控制，子类负责实现 缺点： 修改骨架十分困难 会导致类数量过多 作用：定义一系列的算法步骤，将实现延迟到子类，使得子类能够不改变算法的整体结构，重新定义某些特定的算法步骤 类图：子类通过重写钩子方法可以决定是否执行某些算法步骤 使用场景： 需要控制子类的扩展，以符合算法规则 不同的类中，存在相同的业务流程，出现大量重复代码 命令模式 优点： 实现请求的调用者与请求的执行者解耦 可以实现不同的命令子类，扩展性好 缺点：会导致类的数量过多 作用：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。 类图：通过栈保存命令调用的历史，以此达到撤销命令，还可以结合组合模式执行宏命令（一系列的命令批量执行） 使用场景： 需要撤销多次处理 实现原子事务（出现异常需要回滚） 命令含义稳定，并且希望解耦命令的调用者与执行者 访问者模式 优点： 增加新的访问者（访问操作）十分方便，满足开闭原则 将访问的行为内聚到访问者对象中，让类的职责更清晰，使得复杂对象可供多个不同的访问者访问 不修改结构层次关系，却能对层次添加操作 缺点： 新增具体元素类，不符合开闭原则，每个访问者对象都需要进行修改 访问者访问的元素必须暴露某些内部操作、状态供其使用，破坏了对象的封装性 作用：对操作复杂对象中的不同部分，在改变原有类的前提下，提供不同的操作方法 类图： 使用场景： 一个复杂对象中，存在多种不同的对象，希望根据不同的访问者对这些对象进行不同的操作 复杂对象的结构稳定，并且需要经常为其添加新的操作方式 希望对复杂对象的访问操作分离，避免大量的操作方式让复杂对象过于臃肿 迭代器模式 优点： 将遍历对象与存储对象分离，使得遍历时无需知道其内部结构，降低了耦合性 通过实现不同的迭代器可以替换遍历算法，并且为不同对象的遍历提供了统一的编程方式 对某个聚合对象添加新的遍历算法，只需要实现新的迭代器，符合开闭原则 缺点： 实现不同的遍历器类会导致类数量过多(可以通过内部类实现解决) 对遍历器接口的设计要求很高，若要修改遍历接口，则不符合开闭原则 遍历时，不能修改被遍历的集合，否则会遍历出错 作用：提供一种方法访问聚合对象，而无需知道其内部结构 类图：使用内部类来实现具体迭代器类 使用场景： 访问某个对象的元素而无需暴露其内部结构 需要为某个对象提供多种遍历方式 为不同对象的遍历方式提供统一的遍历操作接口，使得客户端能够统一遍历方式 观察者模式 优点： 将表示层与数据层分离，使得不同层次的对象都可以充当观察者 观察者与被观察者通过抽象耦合，它们无需知道对方具体的实现细节，便可以与对方进行通信 简化了一对多的广播通信等系统的设计难度 增加新的具体观察者符合开闭原则；当观察者与被观察者没有关联时，新增被观察者也十分方便 缺点： 观察者过多，会导致推送更新的时间过长 若观察者和被观察的对象之间存在循环依赖，则观察者模式会触发死循环 观察者无法知道是什么原因导致被观察的目标发生变化 作用：定义对象之间的一对多关系，使得一个对象的状态发生改变，它的观察者都能收到通知并且更新自身持有的信息 类图： 使用场景： 存在两个抽象的模型，且一方依赖于另外一方，则可使用观察者模式在抽象层进行关联，使得它们能够独立的改变与复用 一个对象的改变需要通知其他对象也发生改变，并且不知道这些对象的类型与数量 可以使用观察者模式形成触发链 中介者模式 优点： 将对象间多对多的关联关系转换成一对多的关联关系，简化了编程的复杂度，更容易维护与理解、扩展 解耦具体同事类之间的关联关系，使得它们能够相互独立变化，符合开闭原则 具体同事类可以被子中介者类复用，降低了类的数量 缺点：中介者类中包含大量同事类的交互逻辑，难以维护，容易出错 作用：用一个中介对象封装一系列对象的交互，使这些对象无需显示引用对方，从而降低它们的耦合，让它们能独立变化 类图：同事类One和Two，通过中介者类进行通信。中介者根据具体的同事类，决定执行如何调用其他同事类 使用场景： 系统中的对象存在复杂的引用关系，系统结构混乱并且难以理解 某个对象引用了许多对象，并且与这些对象进行交互，并且希望能复用它 希望通过一个中间类封装多个类中的行为，又不希望创建过多的中间类 备忘录模式（对象行为模式） 优点： 提供对象状态恢复的机制，可用于对象变更成新状态遇到问题时，恢复老状态 通过栈等其他数据结构存储实现，可进行多次撤销操作，即使执行时状态产生了分支，也能回退 缺点：当状态对象过于复杂时，使用备忘录对象保存状态会造成过多的内存开销（需要只记录每次修改变动的部分解决此问题，但其实现将十分困难） 作用：不破坏对象内部封装的前提下，保存其内部状态到其他对象中，当需要恢复状态的时候进行恢复 类图：通过内部类和栈实现多步回退机制 使用场景： 需要保存某一时刻某个对象的所有状态，以便于后续进行恢复 希望将状态对象的变更历史保存到它自己当中，不希望其他对象修改它的变更历史 解释器模式（类行为模式） 优点： 能够轻松实现简单的文法规则，新增文法规则只需要添加新的实现类，符合开闭原则 具体节点类之间存在相似的结构，可以使用工具自动生成相关代码 缺点： 复杂的文法类的数量会过多 执行效率不高（因为解释复杂句子时，存在大量递归与循环调用，并且难以理解与调试） 作用：定义一种语言文法，编写对应的解释器对其进行翻译，执行其具体含义 类图：定义抽象节点（BaseNode）、中间语法节点（ExpressionNode、CommandNode）、语法叶子节点（NonLoopNode、LoopNode），其中表达式节点由多个命令节点组成，命令节点由多个循环或者不循环叶子节点组成，最后通过上下文（Context类）携带的句子信息，使用ExpressionNode节点进行翻译与执行命令 使用场景： 执行效率要求不高，需要进行简单的文法转换 可以用简单文法描述的重复问题（例如：二维平面的移动，确定方向与距离，多次执行命令，便可以到达任何位置） 状态模式（对象行为模式） 优点： 将状态代码与状态对象解耦，便于集中管理控制状态的相关代码 持有不同的状态对象，可以具有不同的功能实现方式 可以通过环境对象共享状态对象，减少所需的具体状态类 缺点： 由于分离了环境对象与其状态，当状态的种类较多时，会产生较多的具体状态类 增加新状态需要修改那些负责转换状态的类，不符合开闭原则 分离状态代码会导致代码的设计难度提升 作用：使得对象的内部状态发生改变，其行为也随之改变 类图：可通过状态类控制状态转换，也可以通过上下文类自身进行状态的控制，还可以通过静态状态成员变量在上下文对象间进行状态共享 使用场景： 对象的行为依赖自身的属性值 模块中存在大量处理、维护状态的语句 策略模式（对象行为模式） 优点： 完全符合开闭原则，可以不修改原有的代码进行新增、修改算法 通过抽象策略类可以复用公共的算法代码，并且具体策略也可以被其他上下文类复用 允许在运行时切换具体的算法实现，并且支持每种不同的算法独立扩展与修改 能够避免大量分支语句块的出现 缺点： 客户端需要理解每种不同的算法，当算法种类过多时，学习成本较大 任何算法的变化都会新增具体策略类，会造成具体策略类过多 无法混用多种策略（比如使用A策略类的前三步，再用B策略类的后三步完成业务处理） 作用：定义一系列的算法，由具体子类实现不同的算法，将这些算法封装起来，使得它们可以相互替换 类图： 使用场景： 模块的运行需要动态切换成某种不同的算法逻辑 业务逻辑存在大量分支语句，存在多重条件选择语句（例如 A &amp;&amp; B &amp;&amp; C），可以通过策略分发的方式消除 不希望客户端知道算法的具体实现逻辑 责任链（职责链）模式（对象行为模式） 分类: 完全（纯职责）职责模式： 请求只能被职责链中的某一个环节处理，不能继续转发至其他节点 不能出现请求没有节点处理的情况 不完全（不纯）职责模式： 请求被某个节点处理后，可以继续传递给后续节点进行处理 可以出现请求没有被任何节点处理的情况 优点： 请求对象与处理对象进行解耦，职责链由客户端创建，降低系统的耦合度 每一位请求处理者只需要维持后一位处理者的引用，而无需知晓全部处理者 可以在运行时修改职责链，从而动态改变处理流程 新增处理节点时，符合开闭原则 缺点： 请求可能会因为职责链的配置错误而无法正确处理 职责链过长，处理性能会受影响，并且调试难度增加 作用：将请求发送者与请求处理者分离（由多个处理对象组成一条处理链，请求沿着链条传递，直到有对象能对请求进行处理） 类图： 使用场景： 多个对象都能处理一个请求，并且需要运行时才确定使用哪个对象进行处理，客户端不关心具体处理请求的对象 想要动态改变请求处理者的先后顺序、处理者的数量等职责链相关的属性","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://b727031867.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"编程经验","slug":"设计模式/编程经验","permalink":"https://b727031867.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"编程基础","slug":"编程基础","permalink":"https://b727031867.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}]},{"title":"Java函数式编程","slug":"Java函数式编程","date":"2020-10-10T14:57:08.000Z","updated":"2020-10-10T15:24:22.890Z","comments":true,"path":"2020/10/10/Java函数式编程/","link":"","permalink":"https://b727031867.github.io/2020/10/10/Java%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","excerpt":"","text":"Java 8 函数式编程 函数式接口：只有单个抽象方法的接口 使用示例： 12345678910111213141516171819202122232425262728293031323334353637/** * @author 龚秀峰 * @version 1.0 * @date 2020/9/29 22:00 */@FunctionalInterfacepublic interface Test&lt;T&gt; &#123; //上述定义了一个函数接口，其中有一个方法test，该方法接收两个泛型对象参数，返回一个泛型对象 T test(T param1,T param2); //函数接口中只能定义一个方法，定义多个方法会导致注解FunctionalInterface报错 //Multiple non-overriding abstract methods found in xxx //这是因为，Java中存在的类型重载，会让javac挑选最明确的类型，但是拉姆达表达式是一段代码，而不是一种类型 //所以无法进行挑选。为了避免歧义，让函数式接口中只能存在一个接口方法&#125;class MyClass implements Test&lt;String&gt;&#123; public static void main(String[] args) &#123; String resStr = new MyClass().test(&quot;a&quot;, &quot;b&quot;); //下面想要通过拉姆达表达式创建类或抽象类的对象，让对象具有不同的行为，不允许！ //new MyClass().test((param1,param2) -&gt; param1 + param2 * param1); //会报错：Target type of a lambda conversion must be an interface System.out.println(resStr); //使用拉姆达表达式，传入另外一种行为，使得接口的ｔｅｓｔ方法具有其他的行为 Test&lt;Integer&gt; iTest = (param1,param2) -&gt; param1 + param2 * param1; Integer res = iTest.test(6, 1); System.out.println(res); &#125; //传统的实现接口方式 @Override public String test(String param1, String param2) &#123; return param1 + param2; &#125;&#125; 运行结果： 常用的函数接口 Supplier：无参数，返回一种结果，T为结果类型 Consumer:接收一个参数，但无返回值，T为参数类型 **Function&lt;T,R&gt;**： 接收一种参数，返回一种结果，T为参数类型，R为结果类型 Predicate ：接收参数，返回Boolean值 高级函数接口：就是定义的参数中包含函数接口，使得高级函数可以传入普通函数（拉姆达表达式） 12345@FunctionalInterfacepublic interface Test&lt;T&gt; &#123; //此方法是高级函数，它的第二个参数可以接收一个拉姆达表达式 T test(T param1,Supplier&lt;T&gt; handler);&#125; 默认方法：为了解决接口新增方法时，所有实现类都必须实现新增的方法的问题，不实现抽象方法的类则采用默认方法中的实现。下图是jdk中集合遍历的默认实现： 默认方法的特点： 需要添加default关键字 只能使用子类的方法修改子类自身，无需知晓子类的具体实现（因为接口本身没有成员变量） 子类中存在该方法，那么会采用子类中的方法（类中重写的方法比默认方法更具体，因此优先级高） 接口可以多继承，多重继承时，出现相同优先级的默认方法，则编译不通过，除非手动选择方法（例如：通过在实现方法中，使用XXX.super关键字，指明XXX是谁，调用的默认方法就是谁的） 接口中的静态方法： Stream&lt;T&gt; of(T t)//从一个集合中获取流，按照顺序有序生成 Stream&lt;T&gt; of(T... values)//从数组中获取流，按照顺序有序生成 12342. &#96;&#96;&#96;java Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) &#x2F;&#x2F;生成流，第一个参数为初始值，第二个参数为根据初始值生成新的初始值，此方法一般要配合limit使用，否则会无限生成流 Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)&#x2F;&#x2F;通过函数生成流对象 Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)//连接两个流 12345678910111213141516171819202122232425262728293031323334357. Optional：可以看作是一个值容器，并且能够容纳null值 1. 用法： &#96;&#96;&#96;java class B&lt;T&gt;&#123; public static void main(String[] args) &#123; B&lt;String&gt; stringB &#x3D; new B&lt;&gt;(); stringB.testOptional(&quot;666&quot;); &#125; public void testOptional(T obj)&#123; &#x2F;&#x2F;构造一个空optional对象 Optional&lt;T&gt; optional &#x3D; Optional.empty(); &#x2F;&#x2F;将传入对象化为optional对象 Optional&lt;T&gt; optional2 &#x3D; Optional.ofNullable(obj); &#x2F;&#x2F;判断这两个optional对象是否相同 boolean equals &#x3D; optional.equals(optional2); System.out.println(equals); &#x2F;&#x2F;判断obj对象的optional对象与obj对象是否相同 equals &#x3D; optional2.equals(obj); System.out.println(equals); &#x2F;&#x2F;如果optional不为空，那么执行拉姆达表达式的内容 optional.ifPresent(System.out::println); &#x2F;&#x2F;如果optional存在，那么返回optional，否则返回参数中的值 T t &#x3D; optional.orElse(obj); System.out.println(&quot;orElse值是：&quot; + t); &#x2F;&#x2F;如果optional2有值，那么会返回值，否则使用拉姆达表达式返回的值(上面的t) Supplier&lt;T&gt; supplier &#x3D; ()-&gt;t; T t1 &#x3D; optional2.orElseGet(supplier); System.out.println(&quot;orElseGet值是：&quot; + t1); &#125; &#125; 2. 注意： - 当希望使用Optional作为参数时，最好使用采用重载实现，因为用Optional作为参数会让调用方复杂 - 当返回值为Optional类型时，调用方必须去处理，以此减少空指针的问题 拉姆达表达式 作用：传递一种行为（代码块），使得同一个函数接口具有不同的行为 基本语法： 无参拉姆达表达式： 12345678//执行的代码只有一行Runnable noParamsForOneRow = ()-&gt; System.out.println(&quot;Hello&quot;);//多行执行代码Runnable noParamsForManyRow = ()-&gt; &#123; System.out.println(&quot;Hello&quot;); System.out.println(&quot;World&quot;); &#125;;//以上的noParamsForOneRow、noParamsForManyRow作为函数接口，可以传入高阶函数（高阶函数能够接收拉姆达表达式），让高阶函数具有不同的行为。以上方法都没有返回值，相当于重写Runnable中的run方法 一个或多个参数的拉姆达表达式： 1234567891011121314151617181920212223242526272829303132333435package leetcode.editor.cn;/** * @author 龚秀峰 * @version 1.0 * @date 2020/9/29 22:00 */@FunctionalInterfacepublic interface Test&lt;T,R,C&gt; &#123; R test(T param1,C param2);&#125;class MyClass implements Test&lt;String,Long,Integer&gt;&#123; public static void main(String[] args) &#123; //这里Double作为返回类型，Double、Long作为参数类型，通过拉姆达表达式传入不同的行为 Test&lt;Double,Double,Long&gt; iTest = (param1,param2) -&gt; param1 + param2 * param1; //不省略参数的类型 Test&lt;Double,Double,Long&gt; iTest2 = (Double param1,Long param2) -&gt; param1 + param2 * param1; //多行要执行的语句，依旧是返回Double类型的值 Test&lt;Double,Double,Long&gt; iTest3 = (Double param1,Long param2) -&gt; &#123; double temp = 0D; temp += param1 + param2 * param1; return temp; &#125;; Double res = iTest.test(6D, 1L); System.out.println(res); &#125; //传统实现接口的方式 @Override public Long test(String param1, Integer param2) &#123; return (long)(param1.length() + param2); &#125;&#125; 方法引用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import org.checkerframework.checker.nullness.qual.Nullable;import java.util.function.Function;import java.util.function.Supplier;/** * @author GXF * @version 0.1.0 * @date 2020-10-05 12:40 * @since 0.1.0 **/public class Test &#123; public static void main(String[] args) &#123; //静态方法引用，将test方法的方法体作为run方法的方法体 Runnable test = A::test; new Thread(test).start(); //构造器引用，将一个参数的构造器作为创建A对象的生产者 Function&lt;String, @Nullable A&gt; constructor = name -&gt; name != null ? new A(name) : null; A a2 = constructor.apply(&quot;777&quot;); assert a2 != null; a2.sayName(); //构造器引用，将默认构造器作为创建A对象的生产者 A a = A.create(A::new); //实例方法引用，将sayName代码块作为run方法的执行体， Runnable sayName = a::sayName; new Thread(sayName).start(); &#125;&#125;class A &#123; private String name = &quot;默认名称&quot;; public A(String name) &#123; this.name = name; &#125; public A() &#123; &#125; public static void test() &#123; System.out.println(&quot;666&quot;); &#125; public void sayName() &#123; System.out.println(this.name); &#125; public static A create(Supplier&lt;A&gt; constructor)&#123; return constructor.get(); &#125;&#125; 注意： 拉姆达表达式中，如果要引用外部的变量，那么该变量必须是既定事实上不变的（所以拉姆达表达式中引用外部的变量实际上是引用外部的值） 123456789101112131415//例如:下面的拉姆达表达式使用了变量t ，但是t不被修改，因此即使t没有final关键字修饰，也不会报错double t = 20DTest&lt;Double,Double,Long&gt; iTest3 = (Double param1,Long param2) -&gt; &#123; double temp = 0D; temp += (param1 + param2 * param1) - t; return temp; &#125;;//下面是报错的情况Test&lt;Double,Double,Long&gt; iTest3 = (Double param1,Long param2) -&gt; &#123; double temp = 0D; //这里修改了外部变量t，所以会报错 t = 10D temp += (param1 + param2 * param1) - t; return temp; &#125;; 为何拉姆达表达式中可以省略参数类型呢？ 12//根据javac中的类型推断，可以从拉姆达表达式的上下文中推断出参数类型、返回值类型，因此可以省略不写参数类型、返回类型Test&lt;Double,Double,Long&gt; iTest = (param1,param2) -&gt; param1 + param2 * param1; 拉姆达表达式可以看作代码块，通过传递代码块来传递行为，同一个函数接口由于传入了不同的行为产生了不同的功能，这是一种多态的体现，可以用于优化某些设计模式，例如：策略模式、命令模式、观察者模式等，无需创建过多的子类，也能达成同一个接口多种行为的目的，但是，对于复杂的接口，不建议采用拉姆达表达式进行简化，应该使用不同的类来实现接口 Steam(流) 作用：用函数式编程更加清晰简洁的操作集合 特性： 流不可复用：用于进行过滤、求值操作后，再进行其他操作则会报错 惰性求值：只有当使用及时求值方法的时候，才会真正进行计算 常用流操作： 过滤器（filter） 2. 转换器（map） 3. 缩放转换器（flatmap） 4. 累积操作器（reduce） 5. 收集器（Collect） 并行流： 注意： 基本类型应该使用其对应的流，避免自动装箱、拆箱，降低性能 并行流采用ForkJoinPool（共享线程池），默认会配分CPU个数的线程，适合CPU密集型的应用，若应用属于IO密集型，则需要自行修改成其他线程池 流对象的顺序与元素的出现顺序相同，即与集合顺序一致，但是当集合无序，那么生成的流也无序，流的顺序会影响流操作的效率，也会影响并行操作的结果 重构旧代码与测试拉姆达表达式 拉姆达与并发","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://b727031867.github.io/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"Java新特性","slug":"Java基础/Java新特性","permalink":"https://b727031867.github.io/categories/Java%E5%9F%BA%E7%A1%80/Java%E6%96%B0%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://b727031867.github.io/tags/Java/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://b727031867.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}]},{"title":"Spring事务","slug":"Spring事务","date":"2020-10-10T14:57:08.000Z","updated":"2020-10-10T15:25:20.562Z","comments":true,"path":"2020/10/10/Spring事务/","link":"","permalink":"https://b727031867.github.io/2020/10/10/Spring%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"Spring事务 特性：ACID 原子性：事务执行的基本单位，保证一个或多个操作要么全部成功，要么全部失败，没有中间状态，失败则回滚至初始状态。 一致性：指系统从一个正确的状态,迁移到另一个正确的状态。这是通过AID来保证的，即事务同时具备原子性、隔离性、持久性，才能保证事务的一致性。 隔离性：不同的事务在提交以前应当对其他事务不可见，但是根据实际情况会分为以下四种隔离级别： 脏读：事务A读取了事务B的中间值，导致数据运算结果不准确。 不可重复读（重点在于修改）：事务A多次读取结果不同，因为事务B在事务A读取的间隙修改了数据。 幻读（重点在于新增与删除）：与不可重复读类似，事务A查询期间事务B插入了数据，事务A再次查询发现多了几条数据（两次数据查询都在同一个事务中） 修改丢失：事务A与事务B同时修改同一数据，导致后完成的事务覆盖之前事务的结果。 持久性：事务执行后涉及的数据将存入存储系统，不会回滚。 隔离级别 TransactionDefinition.ISOLATION_DEFAULT：采用数据库默认的隔离级别。MySQL为可重复读，Oracle为采用可提交读。此为默认设置 TransactionDefinition.ISOLATION_READ_UNCOMMITTED：读未提交数据，可以看见其他事务处理中的数据，隔离级别最低 TransactionDefinition.ISOLATION_READ_COMMITTED：可以读已提交数据（可提交读），能够在A事务中读取B事务的修改与插入的数据。 TransactionDefinition.ISOLATION_REPEATABLE_READ：可重复读，能够在A事务中读取B事务的插入的新数据，无法读取B事务中对旧数据的更新。 TransactionDefinition.ISOLATION_SERIALIZABLE：串行化执行，隔离级别最高 隔离级别与并发问题 一类更新：回滚丢失（Lost update）：对同一数据，事务A与事务B分别执行，事务B提交完毕，事务A回滚，结果回滚撤销了事务B的提交（就像事务B没有执行），所有隔离级别都不允许回滚丢失。 二类更新：多次更新丢失（Second lost update）：事务A与事务B对同一数据进行修改，事务A修改后提交，但事务B的修改基于修改前的值，导致事务B修改后覆盖了事务A提交的值。 隔离级别 一类更新 二类更新 脏读 不可重复读 幻读 读未提交 否 是 是 是 是 读已提交 否 是 否 是 是 可重复读 否 否 否 否 是 串行化 否 否 否 否 否 传播特性（7种） 支持当前事务： PROPAGATION_REQUIRED：当前存在事务则沿用，否则开启新事务 PROPAGATION_SUPPORTS：事务不做强制要求（有就用事务，没有就不用） PROPAGATION MANDATORY：有事务则加入事务，没有事务则抛异常 不支持当前事务： PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。 PROPAGATION_NOT_SUPPORTED：非事务运行，若存在事务，则把当前事务挂起。 PROPAGATION_NEVER：用非事务模式运行，存在事务则抛异常 其他: ROPAGATION_NESTED：存在事务，则开启一个子事务（子事务回滚，不影响外部事务，而外部事务回滚会导致子事务回滚），当前没有事务则等同于PROPAGATION_REQUIRED 控制事务运行的方法 在TransactionStatus接口中，可以设置事务超时时间、是否只读（可以增加性能）以下为常用方法： isNewTransaction(); // 是否是新的事物 hasSavepoint(); // 是否有恢复点 isRollbackOnly(); // 是否为只回滚 boolean isCompleted：是否完成","categories":[{"name":"Spring","slug":"Spring","permalink":"https://b727031867.github.io/categories/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://b727031867.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://b727031867.github.io/tags/Spring/"},{"name":"事务","slug":"事务","permalink":"https://b727031867.github.io/tags/%E4%BA%8B%E5%8A%A1/"}]},{"title":"Docker部署备忘录","slug":"Docker部署备忘录","date":"2020-10-10T14:57:08.000Z","updated":"2020-10-10T15:20:33.947Z","comments":true,"path":"2020/10/10/Docker部署备忘录/","link":"","permalink":"https://b727031867.github.io/2020/10/10/Docker%E9%83%A8%E7%BD%B2%E5%A4%87%E5%BF%98%E5%BD%95/","excerpt":"","text":"Docker部署备忘录Docker的安装 Ubuntu下安装 换源，换成中国科技大学的源 123sudo cp /etc/apt/sources.list /etc/apt/sources.list.baksudo sed -i &#x27;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&#x27; /etc/apt/sources.listsudo apt update 从Ubuntu仓库直接安装 1sudo apt install http://docker.io 启动docker 1sudo systemctl start docker 设置开启自启动 1sudo systemctl enable docker 查看版本 1docker -v Windows10专业版下安装 控制面板-程序与功能-启用或关闭Windows功能：进行启用Hyper-V服务(开启后将无法进行虚拟化，无法使用VMware等沙盒软件) 打开安装包，进行安装 在settings中Shared Drives中：设置共享驱动，一般设置为项目所在盘 在settings中的advance选项中：设置虚拟机存放的路径与虚拟机的cpu、内存等 在settings中的Daemon选项中：设置镜像地址，可以设置阿里云地址进行加速 安装常用镜像 MySQL的安装 下载MySQL镜像8.0版本 1sudo docker pull mysql:8.0 创建需要挂载的文件夹与配置文件 1234567sudo mkdir /home/root/mysql;cd /home/root/mysql;sudo mkdir data;sudo mkdir config;sudo cd config;sudo touch my.cnf;sudo vim my.cnf; 写入的my.cnf 文件内容，用于自定义mysql的配置信息： 1234567891011[mysqld]user&#x3D;mysqlcharacter-set-server&#x3D;utf8mb4#设置密码验证插件default_authentication_plugin&#x3D;mysql_native_password[client]default-character-set&#x3D;utf8mb4[mysql]default-character-set&#x3D;utf8mb4 linux运行mysql，设置容器名称为mysql、设置mysql的持久化目录与配置文件的宿主目录、mysql连接密码，使用host模式则不虚拟网络，直接使用宿主机的网络 12345sudo docker run --name mysql --restart always --privileged=true -p 3306:3306 \\-v /home/root/mysql/data:/var/lib/mysql \\-v /home/root/mysql/config/my.cnf:/etc/my.cnf \\-e MYSQL_USER=&quot;root&quot; -e MYSQL_PASSWORD=&quot;root&quot; \\-e MYSQL_ROOT_PASSWORD=&quot;root&quot; -d mysql:8.0 win10下运行：不使用宿主机网络，则需要设置端口映射 12345docker run --name mysql --restart always --privileged=true -p 3306:3306 `-v H:/DockerFiles/mysql/data:/var/lib/mysql `-v H:/DockerFiles/mysql/config/my.cnf:/etc/my.cnf `-e MYSQL_USER=&quot;root&quot; -e MYSQL_PASSWORD=&quot;root&quot; `-e MYSQL_ROOT_PASSWORD=&quot;root&quot; -d mysql:5.7 Redis的安装 获取镜像 1docker pull redis:5.0.9 创建数据与配置文件的存放目录 1234567mkdir /home/root/redis;cd /home/root/redis;mkdir data;mkdir conf;cd conf;touch redis.conf;vim redis.conf; 将官方对应版本的redis.conf文件的内容粘贴进去，并且修改以下部分 bind 127.0.0.1 改为 #bind 127.0.0.1 关闭限制redis只能本地访问 protected-mode yes 修改为 protected-mode no 关闭限制本地访问 appendonly no 修改为 appendonly yes （可选） 开启追加日志 requirepass 123GONG123 #连接的密码 启动redis， redis-server /etc/redis/redis.conf 表示使用宿主机挂载的配置文件启动 1234sudo docker run --name redis5.0.9 --restart always -d -p 6379:6379 --privileged=true \\ -v /home/root/redis/conf/redis.conf:/etc/redis/redis.conf \\-v /home/root/redis/data:/data \\S redis-server /etc/redis/redis.conf --appendonly yes Java容器的安装及部署项目 获取java镜像 1sudo docker pull java:8-jdk-alpine 打包项目，使用maven进行打包，并且跳过测试 12#到项目根目录下执行打包命令mvn package -Dmaven.test.skip=true 部署项目 12345678910111213141516171819202122mkdir /home/root/project//创建部署项目的目录cd /home/root/project//上传jar包到当前目录下touch Dockerfile//创建docker配置文件vim Dockerfile####文件填入以下内容FROM java:8-jdk-alpineLABEL maintainer=&quot;www.gxf727031867.top&quot;#JAR_FILE参数替换成jar包全称!ARG JAR_FILE=HIS-0.0.1-SNAPSHOT.jar#挂载系统日志VOLUME /home/root/project/Logs:/LogsADD $&#123;JAR_FILE&#125; app.jarEXPOSE 8081ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]####构建镜像，-t指定镜像名称，注意最后有一个点sudo docker build -t his .sudo docker images//查看生成的镜像docker image prune//删除虚悬镜像，即REPOSITORY为none的镜像#运行项目，并且配置挂载日志的目录，注意最后的镜像名称为上文中的his,配置app连接到mysql网络中docker run --network=host -d --privileged=true \\-v /home/root/project/Logs:/Logs --name app his:latest Nginx容器的安装及部署项目 获取nginx镜像 1sudo docker pull nginx 创建用户端目录与管理端目录 12345678#本地打包web项目npm run build#服务器端创建nginx的配置目录、默认配置目录、项目存放目录、日志存放目录mkdir /home/root/nginx/confmkdir /home/root/nginx/conf.dmkdir /home/root/nginx/htmlmkdir /home/root/nginx/logscd /home/root/nginx 上传打包后dist文件夹下的内容到html目录下，其中包含的目录结构如下，客户端dist中的内容上传到client中，后端管理系统dist中的内容上传到admin中。打包vue项目的时，需要在vue.config.js中设置publicPath: ‘/admin/‘**与publicPath: ‘/client/‘**防止静态资源路径错误 获取nginx的配置文件 12345678 #运行nginx docker run -d -p 80:80 --name mynginx nginx #复制容器中的配置文件到宿主机中 docker cp mynginx:/etc/nginx/nginx.conf /home/root/nginx/conf/nginx.conf docker cp mynginx:/etc/nginx/conf.d/default.conf /home/root/nginx/conf.d/default.conf #关闭并且删除当前容器docker stop mynginx docker rm mynginx 首先确保域名绑定了服务器的IP 下载证书申请脚本 12wget https://dl.eff.org/certbot-autochmod 775 certbot-auto 进行申请，-d表示为多个域名申请，*表示通配符。如果只有一个域名，则只用一次-d。运行后会询问是否同意使用条款，选择A；是否公开邮箱，选择Y、是否公开IP记录，选择Y。 123./certbot-auto certonly -d mysite.gxf727031867.top \\--manual --email 1085386394@qq.com \\--preferred-challenges dns --server https://acme-v02.api.letsencrypt.org/directory 前往域名解析处设置DNS记录。脚本运行完毕后会得到主机记录与记录值 设置对应的值，以阿里云为例 可以前往http://dbcha.com/检查是否成功解析 成功解析后，回到控制台按下回车继续申请 申请完成后，证书的目录位于**/etc/letsencrypt/live/[域名]**目录下其中 fullchain.pem文件是完整的证书链 privkey.pem文件是证书私钥 证书有效期为三个月，续签需要使用命令 1./certbot-auto renew 配置nginx的配置文件，实现同一个域名下部署两个vue项目以及https访问 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667user nginx;worker_processes 1;error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn;pid &#x2F;var&#x2F;run&#x2F;nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include &#x2F;etc&#x2F;nginx&#x2F;mime.types; default_type application&#x2F;octet-stream; log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39; &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39; &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;; access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; gzip on; server &#123; listen 80 ; listen [::]:80 ; server_name mysite.gxf727031867.top; if ($host &#x3D; mysite.gxf727031867.top) &#123; return 301 https:&#x2F;&#x2F;$host$request_uri; &#125; return 404; &#125; server &#123; listen 443 ssl http2; server_name mysite.gxf727031867.top; ssl_certificate cert&#x2F;live&#x2F;mysite.gxf727031867.top&#x2F;cert.pem; ssl_certificate_key cert&#x2F;live&#x2F;mysite.gxf727031867.top&#x2F;privkey.pem; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location &#x2F; &#123; root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;client; index index.html index.htm; &#125; location &#x2F;admin &#123; alias &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;admin&#x2F;; index index.html; &#125; &#125; #include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;&#125; 运行nginx并且挂载目录，包括配置与默认配置与日志与证书文件夹 123456docker run --network=host --privileged=true --name nginx -d \\-v /home/root/nginx/html:/usr/share/nginx/html \\-v /home/root/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \\-v /home/root/nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf \\-v /etc/letsencrypt:/etc/nginx/cert \\-v /home/root/nginx/logs:/var/log/nginx nginx MiniO安装 拉取镜像 1docker pull minio/minio 映射端口，与持久化目录，启动服务 123456docker run -p 9000:9000 --privileged=true --restart always -d --name minio \\ -e &quot;MINIO_ACCESS_KEY=AKIAIOSFODNasdE&quot; \\ -e &quot;MINIO_SECRET_KEY=wJalrXUtnFEMI/K7MDasdEXAMPLEKEY&quot; \\ -v /mnt/data:/data \\ -v /mnt/config:/root/.minio \\ minio/minio server /data 访问127.0.0.1:9000即可","categories":[{"name":"持续集成","slug":"持续集成","permalink":"https://b727031867.github.io/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"},{"name":"运维","slug":"持续集成/运维","permalink":"https://b727031867.github.io/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://b727031867.github.io/tags/%E8%BF%90%E7%BB%B4/"},{"name":"容器化","slug":"容器化","permalink":"https://b727031867.github.io/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"},{"name":"持续集成","slug":"持续集成","permalink":"https://b727031867.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"}]},{"title":"计算机网络","slug":"网络知识","date":"2020-10-10T14:57:08.000Z","updated":"2020-10-10T15:18:39.420Z","comments":true,"path":"2020/10/10/网络知识/","link":"","permalink":"https://b727031867.github.io/2020/10/10/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/","excerpt":"","text":"网络知识TCP/IP协议：是OSI的具体实现 OSI七层模型 分层名称 功能 协议 应用层表示层会话层 应用层 文件服务，电子邮件，虚拟终端数据格式化、代码转换、数据加密接触或建立与别的接点的联系 FTP、SNMP、HTTP、DNS等 传输层 传输层 提供端对端接口 TCP、UDP 网络层 网络层 为数据包选择路由 IP、ICMP等 物理层数据链路层 链路层 传输有地址的帧、进行错误检测以二进制数据形式在物理媒体上传输数据 ARP、RARP、MTU等IEEE802、IEEE802.2、ISO2110 OSI开放式互联参考模型：是理论参考模型 分层名称 作用 相关协议或涉及的设备 应用层 规定消息头的组成、消息体长度，让接收方能正确解析内容 SOCKS：安全套接字、SNMP：简单网络管理协议、DNS：域名系统 等等 表示层 信息加密、压缩，根据不同的网络类型格式化数据 XDP：外部数据表示协议、LPP：轻量级表示协议 等等 会话层 建立与管理应用程序之间的通信 SSL：安全套接字层协议、TLS传输层安全协议、RPC远程过程调用协议等 传输层 对发送的数据进行分割（大于1500字节的数据包），为切割后的片段安排序列号，并且保证发送到对端后能够正确重组。 TCP协议、UDP协议 网络层 将网络地址翻译成物理地址，负责将数据从发送方路由到接收方，选择发送数据报的最佳路径 IP/IPV6协议，路由器属于网络层 数据链路层 解决传输过程中错传、误传情况。 提供错误检测与纠正、格式化数据、控制对物理介质的访问，将比特数据组合成帧 交换机负责这一层。ARP地址解析协议、RARP逆向地址解析协议 物理层 传输原始的比特流，主要定义各种传输接口类型、介质、传输速率等 网卡工作在这一层 常见题型TCP的报文头 TCP Flags：SYN(表示建立连接 )、FIN(表示关闭连接)、ACK(表示响应)、PSH(表示有 DATA数据传输)、RST(表示连接重置) seq：Sequence Number 序列号 ack：Acknowledgment Number 响应号 TCP三次握手 首先，服务器某端口处于监听状态，此时客户端发送SYN包（假设SYN值为a）到服务器，自身进入SYN-SENT状态，等待服务器确认 其次，服务器收到SYN包，通过设置ACK=a+1确认收到客户的SYN包，并且自身发送SYN包（设SYN的值为b），即服务器共发送SYN+ACK包，此时服务器进入SYN-RCVD状态 最后，客户端收到SYN+ACK包，向服务器发送ACK=b+1确认包，服务器和客户端进入ESTAB-LISHED状态，完成握手 问题： 为什么需要三次握手才能建立连接？ 为了告知通信双方各自初始Sequence Number（SYN）的值，根据序号检查数据传输过程的顺序、丢包等情况的判断。 大量SYN超时怎么处理？（SYN Flood：恶意发送SYN包，导致连接数耗尽，怎么办？Linux默认63秒才断开连接） Linux下设置tcp_syncookies参数回发SYN Cookie，由于攻击者不响应SYN Cookie，正常的连接在第三次握手时回发， 所以可以迅速关闭长时间未响应的连接 建立连接后，客户端崩溃怎么办？（Client出现故障等特殊情况，如何处理？） 使用保活机制，在客户端丢失响应后的保活时间内，重复发送保活探测报文，多次尝试后未响应，则中断连接。 TCP四次挥手 首先，Client发送FIN=1的包给服务器（假设seq=a），关闭客户端到服务器的数据传输，自身进入FIN-WAIT-1状态 其次，Service收到FIN=1的包后，发送ACK=1给客户端（FIN与SYN包都占用一个传输数，所以ack=a+1），服务器进入CLOSE-WAIT状态，客户端进入FIN-WAIT-2状态 然后，服务器将剩余要传输的数据传输完毕后，发送FIN=1的包（此时ACK=1不变，而seq=b【传输了一段数据】，ack=a+1【因为服务端没有继续发送ack包】），关闭服务器到客户端的数据发送，Server进入LAST-ACK状态 最后，客户端收到FIN=1的包，进入TIME-WAIT状态，并且发送ACK=1的包（此时seq=a+1，ack=b+1【此时客户端发送的响应序数为序列数+1】），服务器进入CLOSED状态，完成挥手 问题： 为什么有TIME-WAIT状态，等待2MSL后才释放连接？ 确保让被动关闭方有足够的时间收到ACK包（TIME_WAIT状态就是用来重发可能丢失的ACK报文） 避免新旧链接混淆（某些路由器会缓存IP数据包） 为什么需要四次挥手，三次行不行？ 因为TCP是全双工通信，并且需要支持半关闭连接(即不发送数据，仍接数据)。 三次挥手时 若去掉最后挥手，服务器端不知道FIN报文是否发送成功，导致服务器一直处于LAST-ACK状态 若合并中间两次挥手，则会导致服务器未传输完毕的数据无法继续传输 服务器出现大量CLOSE-WAIT状态的原因？ 原因： 服务器代码没有及时关闭连接 短时间内大量客户端关闭连接，服务器短期难以处理 服务器忙于读或者写，长时间没有发送FIN包 为什么建立连接只需三次握手，关闭连接却要四次挥手？ 因为服务端在监听状态下，收到SYN报文后，将ACK与SYN放在一个报文中发送给客户端，所以只需三次握手。在关闭连接时，不发送数据但却可能继续接收数据，并且需要由上层应用决定是否关闭发送数据通道，所以ACK与SYN需要分开发送。 TCP与UDP的区别 TCP基于连接，UDP基于无连接，TCP速度慢于UDP TCP数据包报头20字节，UDP数据包报头8字节，UDP额外开销较少 TCP保证数据有序，UDP不保证 TCP更可靠，UDP可能会丢失包 TCP滑动窗口 概念： RTT：发送数据包直到对端回复ACK包所花费的时间 RTO：重传时间间隔（重传机制） 发送窗口包含：已发送未收到ACK包、未发送但允许发送的数据属于发送窗口 接收窗口包含：未接收但准备接收的包 作用：流量控制（流控特性）、乱序重排（保证TCP的可靠性） 滑动方式 对于发送窗口，收到多少个ACK响应包，就滑动多少格 对于接收窗口，只有当接收到本窗口内所有准备接收的包后，才会移动，确保对端能够重传数据 HTTP：以ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。特点：无状态（对与事务处理没有记忆能力，后续处理需要以前的信息，则需要重传）、无连接（传输完毕后断开连接，节省开销）、客户/服务器模式、简单快速、灵活（请求体内容格式可自定） 请求报文 请求行:请求方式（POST,GET,DELETE,PUT,OPTIONS,HEAD,TRACE,CONNECT） 资源路径（URL） HTTP版本号 例如GET/test.html HTTP/1.1 请求头部:由多段报头组成，由字段名（大小写无关）：值组成，主要用于设置请求的参数，例如host用于设置请求的主机与端口号 空行：用于分开请求数据与请求头 请求数据：不规定具体格式，支持JSON、XML等数据格式 响应报文： 状态行:HTTP版本号 状态号 原因描述 例如HTTP/1.1 200 OK 响应头:与请求头类似，包括响应时间、响应长度、响应内容类型等参数 空行:用于分开响应头与响应正文 响应正文:比如HTML、JSON数据等信息HTTPS 特点 内容加密：采用身份验证和数据加密 验证身份：需要申请证书，证书用于给客户端认证 保护数据完整性：防止传输的内容被中间人冒充或者篡改 与HTTP的差异： 端口默认为443 协议为https，HTTPS=HTTP+加密（各类加密算法）+认证（证书）+完整性保护（哈希校验） 需要CA申请的证书 添加了SSL（安全套接层）或TLS（SSL3.0版本后称为TLS）层，密文传输数据 Cookie和Session Cookie 简介：服务器发送给客户端的特殊信息，以文本形式存储在客户端 传输方式：客户端再次发送请求，会回发Cookie，存放于HTTP请求头中。 作用：服务器解析Cookie得到客户端特有的信息，生成对应的内容（比如个人中心等） Session 简介：服务器为每个用户浏览器创建一个会话对象，具有独一无二的SESSIONID 实现方式： 使用Cookie实现： 使用URL回写实现，在服务器响应的所有页面URL中都添加JSESSIONID 作用：通过SESSIONID标识用户 问题 请简述Web中请求与响应的流程 客户端连接web服务器，默认80端口，建立TCP套接字连接 客户端通过TCP套接字发送HTTP请求报文 服务器接收，找到对应的资源进行处理，最后通过TCP套接字响应http报文 释放TCP连接 若请求头中的Connection=close，则服务器主动关闭TCP连接，客户端被动关闭 若请求头中的Connection=keep-alive，则该连接保持一段时间，持续时间内能继续接收请求 客户端解析状态行与响应头，确保请求成功与文档格式、字符集，然后格式化响应正文进行显示 在浏览器中输入URL后发生了什么？ 浏览器查询DNS缓存（优先级：浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、根域名服务器缓存、顶级域名服务器缓存），找到对应的IP地址则直接返回 根据IP和端口与服务器建立TCP连接（三次握手） 浏览器发送HTTP请求 服务器处理HTTP请求，并且响应对应的HTTP报文 浏览器解析渲染页面，结束连接 常见HTTP状态码有哪些？ 1XX：指示信息——表示请求已接收，将继续处理 2XX：成功——表示请求已被成功接收，理解、接受 例如200，正常返回消息 3XX：重定向——表示完成请求必须进行更近一步的操作 例如302，请求的文件被临时移动到别处，最新的URL在Location响应头中 4XX：客户端错误——请求语法错误或请求无法实现 例如404，访问的资源不存在 5XX：服务器端错误——服务器未能实现合法的请求 例如500，服务器内部程序发生错误 GET请求与POST请求的区别 GET请求信息存放在URL中，请求参数以问号分隔，格式为键值对。POST请求信息放在请求体中，安全性高于GET请求，但由于HTTP是明文传输，所以两者安全性都不高。 GET请求由于浏览器存在长度限制，而POST请求没有限制数据长度。 GET请求符合幂等性和安全性（不改变数据库中的数据），POST不符合。 GET请求会被缓存、存储（CDN加速），POST请求不会被缓存。 Cookie和Session的区别 Cookie数据存放在客户的浏览器中，Session数据存放在服务器中。 Session相对于Cookie（Cookie可以在本地被查看）更安全。 Session会占用服务器内存，Cookie能减轻服务器负担","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://b727031867.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"面试","slug":"计算机网络/面试","permalink":"https://b727031867.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"网络基础知识","slug":"网络基础知识","permalink":"https://b727031867.github.io/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"面试","slug":"面试","permalink":"https://b727031867.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Java初识NIO","slug":"初识JavaNIO","date":"2020-10-10T14:57:08.000Z","updated":"2020-10-10T15:22:59.179Z","comments":true,"path":"2020/10/10/初识JavaNIO/","link":"","permalink":"https://b727031867.github.io/2020/10/10/%E5%88%9D%E8%AF%86JavaNIO/","excerpt":"","text":"初识 Java NIO特点: 面向缓冲区(缓冲区可以双向移动，通过管道传输) 非阻塞IO 具有选择器 通道与缓冲区 通道（Channel）：负责传输 描述：表示目标与I/O资源的连接，类似流，但不能直接访问数据，只能与Buffer交互 用途：解决原本DMA设计下，多个IO并发造成总线拥堵的情况 特点：CPU利用率高，无需再向CPU申请IO 类型： 本地I/O FileChannel（阻塞的，没有继承SelectableChannel）：FileInputStream/FileOutputStream RandomAccessFile 网络I/O SocketChannel：TCP ServerSocketChannel：TCP DatagramChannel：UDP 获取方法 支持通道的类调用getChannel()方法获取对应通道 JDK1.7后，NIO2针对通道获取提供静态方法open() JDK1.7后，NIO2的Files工具类可以用newByteChannel()获取通道 使用方法 下面使用非直接缓冲区读取a图片的流输出到b图片中 123456789101112131415//获取某文件输出与输出管道,并且由Java自动关闭流try (FileInputStream fileInputStream = new FileInputStream(&quot;a.png&quot;); FileOutputStream fileOutputStream = new FileOutputStream(&quot;b.png&quot;); FileChannel fileChannel1 = fileInputStream.getChannel(); FileChannel fileChannel2 = fileOutputStream.getChannel(); ) &#123; ByteBuffer byteBuffer = ByteBuffer.allocate(1024); while (fileChannel1.read(byteBuffer) != -1)&#123; byteBuffer.flip(); fileChannel2.write(byteBuffer); byteBuffer.clear(); &#125;&#125; catch (Exception e) &#123; log.error(e.getMessage());&#125; 使用直接缓冲区读取a图片的流输出到b图片中（只有ByteBuffer支持） 123456789101112131415161718try ( //通过静态方法直接获取对应文件的I/O读、写管道 FileChannel fileInChannel = FileChannel.open(Paths.get(&quot;a.png&quot;), StandardOpenOption.READ); //允许写通道覆盖的写入b.png、支持读与写 FileChannel fileOutChannel = FileChannel.open(Paths.get(&quot;b.png&quot;), StandardOpenOption.WRITE,StandardOpenOption.READ,StandardOpenOption.CREATE)) &#123; //映射将缓冲区到非直接内存中 MappedByteBuffer inByteBuffer = fileInChannel.map(FileChannel.MapMode.READ_ONLY,0,fileInChannel.size()); MappedByteBuffer outByteBuffer = fileOutChannel.map(FileChannel.MapMode.READ_WRITE,0,fileInChannel.size()); //创建读取内容所需的字节数组，大小设置为总大小 byte[] bytes = new byte[inByteBuffer.capacity()]; //读取内容到缓冲区中 inByteBuffer.get(bytes); //把缓冲区中的内容通过管道写入文件b.png中,需要StandardOpenOption.READ和StandardOpenOption.WRITE outByteBuffer.put(bytes);&#125; catch (Exception e) &#123; log.error(e.getMessage());&#125; 通道之间数据传输:**transferFrom()与transferTo()**方法可以直接在两个管道之间交互数据1234567891011try ( //通过静态方法直接获取对应文件的I/O读、写管道 FileChannel inChannel = FileChannel.open(Paths.get(&quot;a.png&quot;), StandardOpenOption.READ); //允许写通道覆盖的写入b.png、支持读与写 FileChannel outChannel = FileChannel.open(Paths.get(&quot;b.png&quot;), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE)) &#123; //将in管道的内容写入out管道(利用直接缓冲区) inChannel.transferTo(0,inChannel.size(),outChannel);&#125; catch (Exception e) &#123; log.error(e.getMessage());&#125; 分散(Scatter)与聚集(Gather) 分散读取：将从管道中读取的数据按顺序“分散”填满多个Buffer中 1234567891011121314151617181920212223try ( //获取文件 RandomAccessFile file = new RandomAccessFile(&quot;a.txt&quot;, &quot;rw&quot;); //获取文件IO管道 FileChannel channel = file.getChannel();) &#123; //分配缓冲区大小 ByteBuffer b1 = ByteBuffer.allocate(2); ByteBuffer b2 = ByteBuffer.allocate(200); //分别读取 ByteBuffer[] byteBuffers = &#123;b1, b2&#125;; channel.read(byteBuffers); for (ByteBuffer byteBuffer : byteBuffers) &#123; //修改缓冲区为写模式 byteBuffer.flip(); &#125; System.out.println(&quot;-------b1-------&quot;); System.out.println(new String(b1.array())); System.out.println(&quot;-------b2-------&quot;); System.out.println(new String(b2.array()));&#125; catch (Exception e) &#123; log.error(e.getMessage());&#125; 聚集写入：将多个Buffer按照缓冲区的顺序将position到limit的数据汇集到管道中 12345678910111213141516/** * 聚集写入 */private void testGather(ByteBuffer[] byteBuffers) &#123; try ( //获取文件 RandomAccessFile file = new RandomAccessFile(&quot;b.txt&quot;, &quot;rw&quot;); //获取文件IO管道 FileChannel channel = file.getChannel(); ) &#123; channel.write(byteBuffers); &#125; catch (Exception e) &#123; log.error(e.getMessage()); &#125;&#125; 字符集Charset设置 编码:字符串—&gt; 字节数组 解码:字节数组—&gt;字符串 用法 123456789101112131415161718192021222324252627/** * 字符集编码与解码的运用 */@Testpublic void testCharset()&#123; try &#123; //加载字符集的类 Charset charset = Charset.forName(&quot;GBK&quot;); //获取编码器 CharsetEncoder charsetEncoder = charset.newEncoder(); //获取解码器 CharsetDecoder charsetDecoder = charset.newDecoder(); CharBuffer charBuffer1 = CharBuffer.allocate(1024); charBuffer1.put(&quot;oh my god ! 天哪！&quot;); charBuffer1.flip(); //把字符buffer编码成字节buffer ByteBuffer byteBuffer = charsetEncoder.encode(charBuffer1); for (int i=0;i&lt;byteBuffer.limit();i++) &#123; System.out.println(byteBuffer.get(i)); &#125; //解码buffer字符串，并且输出 CharBuffer charBuffer2 = charsetDecoder.decode(byteBuffer); System.out.println(charBuffer2); &#125;catch (Exception e)&#123; log.error(e.getMessage()); &#125;&#125; 缓冲区（Buffer）：负责存取 根据数据类型不同，有不同的缓冲区（boolean除外）：ByteBuffer、CharBuffer、ShortBuffer、LongBuffer、FloatBuffer、DoubleBuffer，都是通过allocate（int capacity）获取缓冲区 核心属性 capacity：缓冲区最大存储数据的容量，声明后不能改变（数组初始化后大小不能改变） limit：界限，表示缓冲区中可以操作数据的大小（limit之后的数据不能进行读写操作） position：位置，当前缓冲区中正在操作的数据位置 规律：position&lt;=limit&lt;=capacity 缓冲区操作方法： put():存入数据到缓冲区 flip():切换为读数据模式，此时limit变为当前position get():获取缓冲区的数据，读取后当前position加上读取的长度 rewind():重读，让position=0,，mark=-1（取消mark标记） clear():清空缓冲区，让缓冲区的数据处于“被遗忘”的状态（position=0、limit=capacity） mark():标记，记录当前position的位置 reset():重置，回到最近一次mark标记的position位置 hasRemaining():缓冲区是否有剩余字符 remaining():查看当前剩余内容的字符数量 直接缓冲区与非直接缓冲区 直接缓冲区：通过allocateDirect()方法将缓冲区分配在直接内存（物理内存）中，提升效率 非直接缓冲区：通过allocate()方法在JVM中分配缓冲区 非阻塞I/O模式与阻塞式I/O实现 选择器(Selector)：检查一个或多个通道的状态是否可读、可写，是SelecktableChannel的多路复用器 阻塞式I/O:以下实现客户端发送图片a.png服务端接收后另存为s.png，然后告知客户端成功收到图片 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 阻塞I/O的客户端实现 */@Testpublic void clientBlockingTest() &#123; try (SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 9090)); FileChannel fileChannel = FileChannel.open(Paths.get(&quot;a.png&quot;),StandardOpenOption.READ) ) &#123; ByteBuffer byteBuffer = ByteBuffer.allocate(1024); while (fileChannel.read(byteBuffer) != -1)&#123; byteBuffer.flip(); socketChannel.write(byteBuffer); byteBuffer.clear(); &#125; //告知服务端客户端已经发送完毕，否则客户端会一直阻塞，此时仍能接收服务端的消息 socketChannel.shutdownOutput(); while (socketChannel.read(byteBuffer) !=-1)&#123; byteBuffer.flip(); System.out.println(new String(byteBuffer.array(),0,byteBuffer.limit())); byteBuffer.clear(); &#125; //关闭接收的连接 socketChannel.shutdownInput(); &#125; catch (Exception e) &#123; log.error(e.getMessage()); &#125;&#125;/** * 阻塞I/O的服务端实现 */@Testpublic void serverBlockingTest() &#123; try (ServerSocketChannel socketChannel = ServerSocketChannel.open(); FileChannel fileChannel = FileChannel.open(Paths.get(&quot;s.png&quot;),StandardOpenOption.WRITE,StandardOpenOption.CREATE) ) &#123; socketChannel.bind(new InetSocketAddress(9090)); SocketChannel acceptChannel = socketChannel.accept(); ByteBuffer byteBuffer = ByteBuffer.allocate(1024); while (acceptChannel.read(byteBuffer) != -1)&#123; byteBuffer.flip(); fileChannel.write(byteBuffer); byteBuffer.clear(); &#125; //告知客户端已经接收 byteBuffer.put(&quot;成功接收客户端发送的消息！&quot;.getBytes()); byteBuffer.flip(); //发送回客户端 acceptChannel.write(byteBuffer); acceptChannel.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 非阻塞式I/O:以下代码实现客户端向服务端发送消息，服务端输出消息，此过程是非阻塞的，即服务端接收与客户端发送后，都可以继续执行其他业务 123456789101112131415161718192021222324/** * 非阻塞I/O客户端 */@Testpublic void client() &#123; try (SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 6856))) &#123; //切换成非阻塞管道模式 socketChannel.configureBlocking(false); //申请缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); //模拟用户输入 Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) &#123; String next = scanner.next(); System.out.println(&quot;客户端发送：&quot;+next); byteBuffer.put((next).getBytes()); byteBuffer.flip(); socketChannel.write(byteBuffer); byteBuffer.clear(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 非阻塞I/O服务端 */@Testpublic void server() &#123; SocketChannel socketChannel = null; try (ServerSocketChannel serverSocketChannel = ServerSocketChannel.open()) &#123; //切换成非阻塞管道模式 serverSocketChannel.configureBlocking(false); serverSocketChannel.bind(new InetSocketAddress(6856)); Selector selector = Selector.open(); //设置通道的选择器并且确定选择器的监听类型为连接完成 serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); //获取已经准备就绪的管道 while (selector.select() &gt; 0) &#123; Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator(); while (iterator.hasNext()) &#123; SelectionKey key = iterator.next(); //对于完成连接准备的管道 if (key.isAcceptable()) &#123; //创建与客户端的连接 socketChannel = serverSocketChannel.accept(); //切换为非阻塞 socketChannel.configureBlocking(false); //设置当前连接的监听器与监听的事件(读准备就绪事件) socketChannel.register(selector, SelectionKey.OP_READ); &#125; else if (key.isReadable()) &#123; //读准备就绪，打开管道，则进行读取 socketChannel = (SocketChannel) key.channel(); ByteBuffer byteBuffer = ByteBuffer.allocate(1024); int len; while ((len = socketChannel.read(byteBuffer)) &gt; 0) &#123; byteBuffer.flip(); System.out.println(&quot;服务端接收：&quot;+new String(byteBuffer.array(), 0, len)); byteBuffer.clear(); &#125; &#125; //删除处理完的key iterator.remove(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (socketChannel != null) &#123; try &#123; socketChannel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; DatagramChannel：用UDP协议发送数据，多用于视频、语言等场景 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Testpublic void datagramClient()&#123; try(DatagramChannel dc &#x3D; DatagramChannel.open())&#123; dc.configureBlocking(false); ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024); Scanner scanner &#x3D; new Scanner(System.in); while (scanner.hasNext())&#123; String str &#x3D; scanner.next(); byteBuffer.put((str + LocalDateTime.now()).getBytes()); byteBuffer.flip(); dc.send(byteBuffer,new InetSocketAddress(&quot;127.0.0.1&quot;,6666)); byteBuffer.clear(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;&#125;@Testpublic void datagramServer()&#123; try(DatagramChannel ds &#x3D; DatagramChannel.open()) &#123; ds.configureBlocking(false); ds.bind(new InetSocketAddress(6666)); Selector selector &#x3D; Selector.open(); ds.register(selector,SelectionKey.OP_READ); &#x2F;&#x2F;通过轮询获取就绪的key while (selector.select()&gt;0)&#123; Iterator&lt;SelectionKey&gt; iterator &#x3D; selector.selectedKeys().iterator(); while (iterator.hasNext())&#123; SelectionKey sk &#x3D; iterator.next(); if(sk.isReadable())&#123; ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024); ds.receive(byteBuffer); byteBuffer.flip(); System.out.println(new String(byteBuffer.array(),0,byteBuffer.limit())); byteBuffer.clear(); &#125; iterator.remove(); &#125; &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;&#125; Pipe：通过内部的source管道读取与sink管道发送数据，常用于两个线程之间单向数据交互 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 在一个线程中模拟两个线程之间的通信 * 首先写入一些信息，然后再让其读取 */@Testpublic void testPipe() &#123; Pipe.SourceChannel source = null; Pipe.SinkChannel sink = null; try &#123; Pipe pipe = Pipe.open(); ByteBuffer byteBufferA = ByteBuffer.allocate(1024); //A线程获取写管道 sink = pipe.sink(); //A线程写入一些数据到缓冲区中，并且通过sink管道进行发送 byteBufferA.put(&quot;这是A线程写入的内容!&quot;.getBytes()); byteBufferA.flip(); sink.write(byteBufferA); byteBufferA.clear(); //B线程获取读管道 source = pipe.source(); //读取A线程的内容到B线程的缓冲区，然后输出该内容 ByteBuffer byteBufferB = ByteBuffer.allocate(1024); source.read(byteBufferB); byteBufferB.flip(); System.out.println(new String(byteBufferB.array(),0,byteBufferB.limit())); byteBufferB.clear(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (source != null) &#123; try &#123; source.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (sink != null) &#123; try &#123; sink.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://b727031867.github.io/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"Java网络编程","slug":"Java基础/Java网络编程","permalink":"https://b727031867.github.io/categories/Java%E5%9F%BA%E7%A1%80/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://b727031867.github.io/tags/Java/"},{"name":"网络编程","slug":"网络编程","permalink":"https://b727031867.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"异步编程","slug":"异步编程","permalink":"https://b727031867.github.io/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"}]}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://b727031867.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"编程经验","slug":"设计模式/编程经验","permalink":"https://b727031867.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C/"},{"name":"Java基础","slug":"Java基础","permalink":"https://b727031867.github.io/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"Java新特性","slug":"Java基础/Java新特性","permalink":"https://b727031867.github.io/categories/Java%E5%9F%BA%E7%A1%80/Java%E6%96%B0%E7%89%B9%E6%80%A7/"},{"name":"Spring","slug":"Spring","permalink":"https://b727031867.github.io/categories/Spring/"},{"name":"持续集成","slug":"持续集成","permalink":"https://b727031867.github.io/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"},{"name":"运维","slug":"持续集成/运维","permalink":"https://b727031867.github.io/categories/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/%E8%BF%90%E7%BB%B4/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://b727031867.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"面试","slug":"计算机网络/面试","permalink":"https://b727031867.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95/"},{"name":"Java网络编程","slug":"Java基础/Java网络编程","permalink":"https://b727031867.github.io/categories/Java%E5%9F%BA%E7%A1%80/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程基础","slug":"编程基础","permalink":"https://b727031867.github.io/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"Java","slug":"Java","permalink":"https://b727031867.github.io/tags/Java/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://b727031867.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"name":"Spring","slug":"Spring","permalink":"https://b727031867.github.io/tags/Spring/"},{"name":"事务","slug":"事务","permalink":"https://b727031867.github.io/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"运维","slug":"运维","permalink":"https://b727031867.github.io/tags/%E8%BF%90%E7%BB%B4/"},{"name":"容器化","slug":"容器化","permalink":"https://b727031867.github.io/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"},{"name":"持续集成","slug":"持续集成","permalink":"https://b727031867.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"},{"name":"网络基础知识","slug":"网络基础知识","permalink":"https://b727031867.github.io/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"面试","slug":"面试","permalink":"https://b727031867.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"网络编程","slug":"网络编程","permalink":"https://b727031867.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"异步编程","slug":"异步编程","permalink":"https://b727031867.github.io/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"}]}