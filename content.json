{"meta":{"title":"一叶知秋","subtitle":"大道至简，知易行难，知行合一，得到功成","description":"本博客主要用于记录、分享编程之路遇到的那些事儿~","author":"Mr.G","url":"https://b727031867.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-06-30T13:44:55.469Z","updated":"2021-05-30T11:54:50.000Z","comments":false,"path":"/404.html","permalink":"https://b727031867.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-01T15:27:47.620Z","updated":"2021-07-01T15:27:47.620Z","comments":false,"path":"about/index.html","permalink":"https://b727031867.github.io/about/index.html","excerpt":"","text":"一个热爱学习编程，擅长团队合作，希望用代码让世界变得美好的小菜鸟~"},{"title":"分类","date":"2021-06-30T13:44:55.505Z","updated":"2021-05-30T11:54:50.000Z","comments":false,"path":"categories/index.html","permalink":"https://b727031867.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-06-30T13:44:55.522Z","updated":"2021-05-30T11:54:50.000Z","comments":false,"path":"repository/index.html","permalink":"https://b727031867.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-06-30T13:44:55.515Z","updated":"2021-05-30T11:54:50.000Z","comments":true,"path":"links/index.html","permalink":"https://b727031867.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-06-30T13:44:55.529Z","updated":"2021-05-30T11:54:50.000Z","comments":false,"path":"tags/index.html","permalink":"https://b727031867.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java函数式编程体验","slug":"Java函数式编程","date":"2021-07-15T02:41:10.000Z","updated":"2021-07-01T14:35:46.820Z","comments":true,"path":"2021/07/15/Java函数式编程/","link":"","permalink":"https://b727031867.github.io/2021/07/15/Java%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","excerpt":"","text":"Java 8 函数式编程读书笔记 函数式接口：只有单个抽象方法的接口 使用示例： 12345678910111213141516171819202122232425262728293031323334353637/** * @author 龚秀峰 * @version 1.0 * @date 2020/9/29 22:00 */@FunctionalInterfacepublic interface Test&lt;T&gt; &#123; //上述定义了一个函数接口，其中有一个方法test，该方法接收两个泛型对象参数，返回一个泛型对象 T test(T param1,T param2); //函数接口中只能定义一个方法，定义多个方法会导致注解FunctionalInterface报错 //Multiple non-overriding abstract methods found in xxx //这是因为，Java中存在的类型重载，会让javac挑选最明确的类型，但是拉姆达表达式是一段代码，而不是一种类型 //所以无法进行挑选。为了避免歧义，让函数式接口中只能存在一个接口方法&#125;class MyClass implements Test&lt;String&gt;&#123; public static void main(String[] args) &#123; String resStr = new MyClass().test(&quot;a&quot;, &quot;b&quot;); //下面想要通过拉姆达表达式创建类或抽象类的对象，让对象具有不同的行为，不允许！ //new MyClass().test((param1,param2) -&gt; param1 + param2 * param1); //会报错：Target type of a lambda conversion must be an interface System.out.println(resStr); //使用拉姆达表达式，传入另外一种行为，使得接口的ｔｅｓｔ方法具有其他的行为 Test&lt;Integer&gt; iTest = (param1,param2) -&gt; param1 + param2 * param1; Integer res = iTest.test(6, 1); System.out.println(res); &#125; //传统的实现接口方式 @Override public String test(String param1, String param2) &#123; return param1 + param2; &#125;&#125; 运行结果： 常用的函数接口 Supplier：无参数，返回一种结果，T为结果类型 Consumer:接收一个参数，但无返回值，T为参数类型 Function&lt;T,R&gt;： 接收一种参数，返回一种结果，T为参数类型，R为结果类型 Predicate ：接收参数，返回Boolean值 高级函数接口：就是定义的参数中包含函数接口，使得高级函数可以传入普通函数（拉姆达表达式） 12345@FunctionalInterfacepublic interface Test&lt;T&gt; &#123; //此方法是高级函数，它的第二个参数可以接收一个拉姆达表达式 T test(T param1,Supplier&lt;T&gt; handler);&#125; 默认方法：为了解决接口新增方法时，所有实现类都必须实现新增的方法的问题，不实现抽象方法的类则采用默认方法中的实现。下图是jdk中集合遍历的默认实现： 默认方法的特点： 需要添加default关键字 只能使用子类的方法修改子类自身，无需知晓子类的具体实现（因为接口本身没有成员变量） 子类中存在该方法，那么会采用子类中的方法（类中重写的方法比默认方法更具体，因此优先级高） 接口可以多继承，多重继承时，出现相同优先级的默认方法，则编译不通过，除非手动选择方法（例如：通过在实现方法中，使用XXX.super关键字，指明XXX是谁，调用的默认方法就是谁的） 接口中的静态方法： Stream&lt;T&gt; of(T t)//从一个集合中获取流，按照顺序有序生成 Stream&lt;T&gt; of(T... values)//从数组中获取流，按照顺序有序生成 12342. &#96;&#96;&#96;java Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) &#x2F;&#x2F;生成流，第一个参数为初始值，第二个参数为根据初始值生成新的初始值，此方法一般要配合limit使用，否则会无限生成流 Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)&#x2F;&#x2F;通过函数生成流对象 Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)//连接两个流 12345678910111213141516171819202122232425262728293031323334357. Optional：可以看作是一个值容器，并且能够容纳null值 1. 用法： &#96;&#96;&#96;java class B&lt;T&gt;&#123; public static void main(String[] args) &#123; B&lt;String&gt; stringB &#x3D; new B&lt;&gt;(); stringB.testOptional(&quot;666&quot;); &#125; public void testOptional(T obj)&#123; &#x2F;&#x2F;构造一个空optional对象 Optional&lt;T&gt; optional &#x3D; Optional.empty(); &#x2F;&#x2F;将传入对象化为optional对象 Optional&lt;T&gt; optional2 &#x3D; Optional.ofNullable(obj); &#x2F;&#x2F;判断这两个optional对象是否相同 boolean equals &#x3D; optional.equals(optional2); System.out.println(equals); &#x2F;&#x2F;判断obj对象的optional对象与obj对象是否相同 equals &#x3D; optional2.equals(obj); System.out.println(equals); &#x2F;&#x2F;如果optional不为空，那么执行拉姆达表达式的内容 optional.ifPresent(System.out::println); &#x2F;&#x2F;如果optional存在，那么返回optional，否则返回参数中的值 T t &#x3D; optional.orElse(obj); System.out.println(&quot;orElse值是：&quot; + t); &#x2F;&#x2F;如果optional2有值，那么会返回值，否则使用拉姆达表达式返回的值(上面的t) Supplier&lt;T&gt; supplier &#x3D; ()-&gt;t; T t1 &#x3D; optional2.orElseGet(supplier); System.out.println(&quot;orElseGet值是：&quot; + t1); &#125; &#125; 注意： 当希望使用Optional作为参数时，最好使用采用重载实现，因为用Optional作为参数会让调用方复杂 当返回值为Optional类型时，调用方必须去处理，以此减少空指针的问题 拉姆达表达式 作用：传递一种行为（代码块），使得同一个函数接口具有不同的行为 基本语法： 无参拉姆达表达式： 12345678//执行的代码只有一行Runnable noParamsForOneRow = ()-&gt; System.out.println(&quot;Hello&quot;);//多行执行代码Runnable noParamsForManyRow = ()-&gt; &#123; System.out.println(&quot;Hello&quot;); System.out.println(&quot;World&quot;); &#125;;//以上的noParamsForOneRow、noParamsForManyRow作为函数接口，可以传入高阶函数（高阶函数能够接收拉姆达表达式），让高阶函数具有不同的行为。以上方法都没有返回值，相当于重写Runnable中的run方法 一个或多个参数的拉姆达表达式： 1234567891011121314151617181920212223242526272829303132333435package leetcode.editor.cn;/** * @author 龚秀峰 * @version 1.0 * @date 2020/9/29 22:00 */@FunctionalInterfacepublic interface Test&lt;T,R,C&gt; &#123; R test(T param1,C param2);&#125;class MyClass implements Test&lt;String,Long,Integer&gt;&#123; public static void main(String[] args) &#123; //这里Double作为返回类型，Double、Long作为参数类型，通过拉姆达表达式传入不同的行为 Test&lt;Double,Double,Long&gt; iTest = (param1,param2) -&gt; param1 + param2 * param1; //不省略参数的类型 Test&lt;Double,Double,Long&gt; iTest2 = (Double param1,Long param2) -&gt; param1 + param2 * param1; //多行要执行的语句，依旧是返回Double类型的值 Test&lt;Double,Double,Long&gt; iTest3 = (Double param1,Long param2) -&gt; &#123; double temp = 0D; temp += param1 + param2 * param1; return temp; &#125;; Double res = iTest.test(6D, 1L); System.out.println(res); &#125; //传统实现接口的方式 @Override public Long test(String param1, Integer param2) &#123; return (long)(param1.length() + param2); &#125;&#125; 方法引用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import org.checkerframework.checker.nullness.qual.Nullable;import java.util.function.Function;import java.util.function.Supplier;/** * @author GXF * @version 0.1.0 * @date 2020-10-05 12:40 * @since 0.1.0 **/public class Test &#123; public static void main(String[] args) &#123; //静态方法引用，将test方法的方法体作为run方法的方法体 Runnable test = A::test; new Thread(test).start(); //构造器引用，将一个参数的构造器作为创建A对象的生产者 Function&lt;String, @Nullable A&gt; constructor = name -&gt; name != null ? new A(name) : null; A a2 = constructor.apply(&quot;777&quot;); assert a2 != null; a2.sayName(); //构造器引用，将默认构造器作为创建A对象的生产者 A a = A.create(A::new); //实例方法引用，将sayName代码块作为run方法的执行体， Runnable sayName = a::sayName; new Thread(sayName).start(); &#125;&#125;class A &#123; private String name = &quot;默认名称&quot;; public A(String name) &#123; this.name = name; &#125; public A() &#123; &#125; public static void test() &#123; System.out.println(&quot;666&quot;); &#125; public void sayName() &#123; System.out.println(this.name); &#125; public static A create(Supplier&lt;A&gt; constructor)&#123; return constructor.get(); &#125;&#125; 可用拉姆达表达式解决的问题 处理基于事件驱动的回调 实现基于消息传递架构的系统 3. 进行响应式编程 注意： 拉姆达表达式中，如果要引用外部的变量，那么该变量必须是既定事实上不变的（所以拉姆达表达式中引用外部的变量实际上是引用外部的值） 123456789101112131415//例如:下面的拉姆达表达式使用了变量t ，但是t不被修改，因此即使t没有final关键字修饰，也不会报错double t = 20DTest&lt;Double,Double,Long&gt; iTest3 = (Double param1,Long param2) -&gt; &#123; double temp = 0D; temp += (param1 + param2 * param1) - t; return temp; &#125;;//下面是报错的情况Test&lt;Double,Double,Long&gt; iTest3 = (Double param1,Long param2) -&gt; &#123; double temp = 0D; //这里修改了外部变量t，所以会报错 t = 10D temp += (param1 + param2 * param1) - t; return temp; &#125;; 为何拉姆达表达式中可以省略参数类型呢？ 12//根据javac中的类型推断，可以从拉姆达表达式的上下文中推断出参数类型、返回值类型，因此可以省略不写参数类型、返回类型Test&lt;Double,Double,Long&gt; iTest = (param1,param2) -&gt; param1 + param2 * param1; 拉姆达表达式可以看作代码块，通过传递代码块来传递行为，同一个函数接口由于传入了不同的行为产生了不同的功能，这是一种多态的体现，可以用于优化某些设计模式，例如：策略模式、命令模式、观察者模式等，无需创建过多的子类，也能达成同一个接口多种行为的目的，但是，对于复杂的接口，不建议采用拉姆达表达式进行简化，应该使用不同的类来实现接口 Steam(流) 作用：用函数式编程更加清晰简洁的操作集合 特性： 流不可复用：用于进行过滤、求值操作后，再进行其他操作则会报错 惰性求值：只有当使用及时求值方法的时候，才会真正进行计算 常用流操作： 过滤器（filter）：用于筛选某些流对象，不会立即求值 转换器（map）：用于将流对象转换成另外的流对象，一对一转换，不会立即求值 缩放转换器（flatmap）：用于将流对象转换成另外的流对象，一对多转换，不会立即求值 累积操作器（reduce）：设置一个初始值，将初始值和流集合中的第一个值进行操作，得到的值作为第二次操作的初始值，与流集合中的第二个值进行操作，以此类推到流集合中最后一个值为止，会及时求值 收集器（Collect）：设置一种规则，将流集合中的流对象转成某种具体的集合 1234567891011121314151617181920212223//简单使用示例：public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;a&quot;); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;); Stream&lt;String&gt; strStream1 = list.stream(); Stream&lt;String&gt; strStream2 = list.stream(); //过滤，只留下 a，将a转换a,b，收集新的集合 String res = strStream1.filter(&quot;a&quot;::contains).map(value -&gt; value + &quot;,&quot; + &quot;b&quot;).flatMap(value -&gt; &#123; //将a，b分割成list，转成成流对象加入到原有的流集合中 String[] temp = value.split(&quot;,&quot;); List&lt;String&gt; strings = new ArrayList&lt;&gt;(); Collections.addAll(strings,temp); return strings.stream(); //reduce 将每次操作的字符串加上下一个字符串，第一次操作是 &quot;&quot; + 第一个流对象 == 第二次开始操作的值 &#125;).reduce(&quot;&quot;, (current, next) -&gt; current + &quot;:&quot; + next); System.out.println(res); //直接将流转成具体的字符串集合，并且输出 List&lt;String&gt; strList = strStream2.collect(toList()); strList.forEach(System.out::println); &#125; 运行结果： 并行流：parallelStream 使用方法：将使用stream的地方换为paralleStream即可 使用场景： 与执行顺序无关：执行顺序有关会严重影响速度 任务之间应该独立，不竞争同一资源：竞争资源会导致线程安全问题 是否需要并行：数据量小则不需要，实际情况需要自行进行基准测试，分析 注意事项： 并行流采用ForkJoinPool（共享线程池），默认会配分CPU个数的线程，若某个任务很慢，则会堵塞其他想要并行的任务，适合CPU密集型的应用，若应用属于IO密集型，则需要自行修改成其他线程池 事务会失效：Spring的事务通过ThreadLocal进行维护，而并行流会开出多个线程执行，非主线程没有办法获取事务的上下文，事务便会失效 allMatch：全部满足条件返回true，但是空的流集合调用也是返回true 线程安全问题：若并行执行的任务会使用临界资源，那么可能会导致线程安全问题 某些操作在并行流上的性能不高：例如：findFirst、limit等 关注并行的代价：切分任务、执行任务、合并任务结果，每一步的性能消耗，最终是否导致并行的执行效率不如串行 其他： 基本类型应该使用其对应的流，避免自动装箱、拆箱，降低性能 流对象的顺序与元素的出现顺序相同，即与集合顺序一致，但是当集合无序，那么生成的流也无序，流的顺序会影响流操作的效率，也会影响并行操作的结果 重构旧代码与测试拉姆达表达式 重构候选项 未封装的局部状态：通过拉姆达传入表达式，可以在被调用的方法内部检查状态，无需调用者进行检查 12345678910111213141516171819202122232425262728293031323334353637383940414243class A &#123; private String name = &quot;默认名称&quot;; public A(String name) &#123; this.name = name; &#125; public A() &#123; &#125; public static void main(String[] args) &#123; //此时，需要调用isDebugEnabled检查log对象内部的状态，然后输出666 A a = new A(); if(a.checkName())&#123; System.out.println(&quot;是默认名称，才执行这个操作1&quot;); &#125; //使用拉姆达表达式进行重构，这样调用方无需检查 a.checkName(()-&gt; System.out.println(&quot;是默认名称，才执行这个操作2&quot;)); &#125; public static void test() &#123; System.out.println(&quot;666&quot;); &#125; public boolean checkName() &#123; return name.equals(&quot;默认名称&quot;); &#125; public void checkName(Runnable checker)&#123; if(this.checkName())&#123; checker.run(); &#125; &#125; public void sayName() &#123; System.out.println(this.name); &#125; public static A create(Supplier&lt;A&gt; constructor)&#123; return constructor.get(); &#125;&#125; 代替匿名内部类、方法：例如事件监听器、添加、继承某个类只为重写其中的一个方法等情况 同样的代码出现了多次 调试 为了便于调试，可以使用方法引用，而不是直接写拉姆达表达式代码块 Mock测试，可以使用拉姆达表达式模拟不同的替身对象 peek方法，调用该方法可以在该方法中打断点，便于调试，即便该方法是空方法也可以（某些IDE可能不支持空方法打断点），在peek方法中打印输出想要查看的中间结果","categories":[{"name":"Java","slug":"Java","permalink":"https://b727031867.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://b727031867.github.io/tags/Java/"}]},{"title":"Spring事务","slug":"Spring事务","date":"2021-06-29T04:41:10.000Z","updated":"2021-06-29T13:53:35.812Z","comments":true,"path":"2021/06/29/Spring事务/","link":"","permalink":"https://b727031867.github.io/2021/06/29/Spring%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"Spring事务 特性：ACID 原子性：事务执行的基本单位，保证一个或多个操作要么全部成功，要么全部失败，没有中间状态，失败则回滚至初始状态。 一致性：指系统从一个正确的状态,迁移到另一个正确的状态。这是通过AID来保证的，即事务同时具备原子性、隔离性、持久性，才能保证事务的一致性。 隔离性：不同的事务在提交以前应当对其他事务不可见，但是根据实际情况会分为以下四种隔离级别： 脏读：事务A读取了事务B的中间值，导致数据运算结果不准确。 不可重复读（重点在于修改）：事务A多次读取结果不同，因为事务B在事务A读取的间隙修改了数据。 幻读（重点在于新增与删除）：与不可重复读类似，事务A查询期间事务B插入了数据，事务A再次查询发现多了几条数据（两次数据查询都在同一个事务中） 修改丢失：事务A与事务B同时修改同一数据，导致后完成的事务覆盖之前事务的结果。 持久性：事务执行后涉及的数据将存入存储系统，不会回滚。 隔离级别 TransactionDefinition.ISOLATION_DEFAULT：采用数据库默认的隔离级别。MySQL为可重复读，Oracle为采用可提交读。此为默认设置 TransactionDefinition.ISOLATION_READ_UNCOMMITTED：读未提交数据，可以看见其他事务处理中的数据，隔离级别最低 TransactionDefinition.ISOLATION_READ_COMMITTED：可以读已提交数据（可提交读），能够在A事务中读取B事务的修改与插入的数据。 TransactionDefinition.ISOLATION_REPEATABLE_READ：可重复读，能够在A事务中读取B事务的插入的新数据，无法读取B事务中对旧数据的更新。 TransactionDefinition.ISOLATION_SERIALIZABLE：串行化执行，隔离级别最高 不同隔离级别对应的并发问题：（表格中，“是”说明存在该类问题） 一类更新：回滚丢失（Lost update）：对同一数据，事务A与事务B分别执行，事务B提交完毕，事务A回滚，结果回滚撤销了事务B的提交（就像事务B没有执行），所有隔离级别都不允许回滚丢失。 二类更新：多次更新丢失（Second lost update）：事务A与事务B对同一数据进行修改，事务A修改后提交，但事务B的修改基于修改前的值，导致事务B修改后覆盖了事务A提交的值。 隔离级别 一类更新 二类更新 脏读 不可重复读 幻读 读未提交 否 是 是 是 是 读已提交 否 是 否 是 是 可重复读 否 否 否 否 是 串行化 否 否 否 否 否 传播特性（7种） 支持当前事务： PROPAGATION_REQUIRED：当前存在事务则沿用，否则开启新事务 PROPAGATION_SUPPORTS：事务不做强制要求（有就用事务，没有就不用） PROPAGATION MANDATORY：有事务则加入事务，没有事务则抛异常 不支持当前事务： PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。 PROPAGATION_NOT_SUPPORTED：非事务运行，若存在事务，则把当前事务挂起。 PROPAGATION_NEVER：用非事务模式运行，存在事务则抛异常 其他: ROPAGATION_NESTED：存在事务，则开启一个子事务（子事务回滚，不影响外部事务，而外部事务回滚会导致子事务回滚），当前没有事务则等同于PROPAGATION_REQUIRED 事务的运行状态 TransactionStatus接口的相关方法与属性，除此之外可以设置事务超时时间以及是否是只读事务（增加性能） isNewTransaction(); // 是否是新的事物 hasSavepoint(); // 是否有恢复点 isRollbackOnly(); // 是否为只回滚 boolean isCompleted()：是否完成 编程风格 声明式事务：通过Spring AOP 实现 编程式事务 事务不生效常见原因 当前对象未被SpringIoC容器管理 解决方法：注入当前对象到Spring的IoC容器中 数据库存储引擎不支持事务，例如MySQL的MyISAM存储引擎 解决方法：若业务允许，使用InnoDB存储引擎，其他数据库类似，选择支持事务的存储引擎 当前Bean被过早的初始化，导致未执行postProcessAfterInitialization方法生成代理对象，因此事务无法生效 例如：若实现BeanPostProcessor和PriorityOrdered接口，则在依赖此BeanPostProcessor的@Configuration类中，其他依赖的Bean都会被过早初始化 解决办法： BeanPostProcessor单独在某个@Configuration中使用 使用static 方法注册后置处理器（BeanPostProcessor） 方法非Public，@Transactional 只能用于 public 的方法上 解决方法：若要代理非Public方法开启事务，需开启 AspectJ 代理模式 自身调用 1234567891011121314151617181920212223@Servicepublic class ServiceImpl implements Service &#123; @Transactional public void test1() &#123; test2(); &#125; @Transactional(propagation = Propagation.REQUIRES_NEW) public void test2() &#123; // 数据库操作 &#125; public void test3() &#123; test4() &#125; @Transactional public void test4() &#123; // 数据库操作 &#125;&#125; 上述代码中，调用test1()事务不会生效，调用test3()事务也不生效，由于这些调用是在同一个类内部进行调用，并未使用代理对象进行方法调用，因此事务不会生效 解决办法： 在当前类中注入这个类本身，然后再用注入的对象调用方法 配置&lt;aop:aspectj-autoproxy expose-proxy=“true”&gt; ，然后通过代理对象调用方法 ((Service)AopContext.currentProxy()).test1()，此时可以触发传播事务PROPAGATION_REQUIRES_NEW，即test1() 和 test3()方法会在两个不同的事务中运行，test3()异常后回滚不会影响test1()的事务 事务管理器未配置PlatformTransactionManager 未被注入到当前Ioc容器中 1234@Beanpublic PlatformTransactionManager transactionManager(DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource);&#125; 解决方法：根据需求注入需要的事务管理器 事务传播特性设置错误 若设置NOT_SUPPORTED传播级别，则若存在其他事务，则会被挂起，当前方法中执行的各种数据操作都不会被事务管理，方法执行完毕后再恢复事务。 解决方法：正确设置传播特性 异常未正确抛出 解决方法：检查代码，捕获异常后，需要判断是否需要进行事务的回滚，若需要回滚，则该异常要抛出 事务回滚异常设置错误 解决方法：@Transactional(rollbackFor = Exception.class)，设置后，包括非RuntimeException异常也会回滚","categories":[{"name":"Spring","slug":"Spring","permalink":"https://b727031867.github.io/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://b727031867.github.io/tags/Spring/"}]},{"title":"设计模式","slug":"设计模式笔记","date":"2021-04-29T02:41:10.000Z","updated":"2021-06-30T15:20:13.106Z","comments":true,"path":"2021/04/29/设计模式笔记/","link":"","permalink":"https://b727031867.github.io/2021/04/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/","excerpt":"","text":"设计模式学习笔记 七大设计原则 单一职责原则：一个类只负责一项职责 作用：防止修改代码时，影响其他功能，降低类之间的耦合 注意：逻辑简单，可以违背类级别的单一职责，即一个类包含多个功能，但是，最低要保证方法的职责单一 接口隔离原则：类只依赖所需的最小接口 作用：避免实现自身用不到的方法、降低耦合，提高代码阅读性 特点：把通用的方法抽取到更小的接口中，类实现多个小接口来满足自身的需要 依赖倒置（倒转）原则：抽象不依赖细节，细节依赖抽象 作用：让代码更加稳定，减少修改的可能性（抽象层较为稳定）；通过接口与抽象类编写规范，交给实现类完成功能。 特点：面向接口编程，通过传递接口参数，根据具体实现类的不同而完成不同的功能。相当于通过接口进行耦合，避免了类与类之间的强耦合。 里氏替换原则：能用父类的位置都能用子类替换 作用：减少继承的使用，通过聚合、组合、依赖三种类的关系来取代继承；防止子类无意中重写父类方法，而导致程序出错（如果子类重写了父类方法，将调用子类的实现方法，可能导致与原来不同的结果） 特点：子类尽量不重写父类方法，运用父类的位置可以替换成子类。 开闭原则：对扩展开放，对修改关闭 作用：能够避免修改代码，灵活扩充功能（是使用设计模式的最终目标，上述原则作为此原则的铺垫） 特点：使用（调用）方无需修改代码，提供方可以通过添加抽象方法直接添加功能（由子类实现功能） 迪米特原则（最小知道原则）：类对依赖的类知道的越少越好 作用：降低类之间的耦合 特点：只和直接关联的类通信，类自身的逻辑应该由自身内部完成，对外只提供公开方法 直接关联的类：成员方法、方法参数、返回值用到的类（局部变量使用的类不属于） 合成复用原则：少用继承，多用组合、聚合代替继承 特点：通过少用继承，多用依赖的方式降低类之间的耦合度 UML 作用：统一建模语言，用于描述软件模型中各个元素之间的关系 分类 动态图： 序列图 协作图 状态图 活动图 静态图： 用例图 类图 对象图 包图 构件图 部署图 类关系 依赖关系：类中使用了其他类（范围最大），则它们存在依赖关系 关联关系：具有方向性，用于表示对象间的数量关系（1：1、1：n、n：n） 聚合关系：整体与部分可以分割（例如：你与你的电脑，电脑可有可无） 组合关系：整体与部分不可分割——同生共死（比如脸上含有眼睛、嘴巴等） 泛化关系：依赖关系的特例，表示继承关系 实现关系：依赖关系的特例，表示它与它实现接口的关系 23种设计模式 创建型：用于对象创建管理 单例模式 作用：确保重量级对象只返回一个实例，避免资源浪费、并发问题；对于频繁创建与销毁对象的情况，可以提高性能 常见写法： 饿汉式 静态常量饿汉式实现： 优点：实现简洁，通过类装载机制保证线程安全 缺点：无法懒加载，可能浪费内存 实现步骤： 构造方法私有 静态成员变量new自身（无法懒加载） 提供公有静态方法获取成员实例 静态代码块饿汉式实现 只是把上述new的过程放入静态代码块实现，优缺点、步骤同上 懒汉式 线程不安全懒汉式实现 优点：懒加载 缺点：线程不安全（不建议使用） 实现步骤 构造器私有 定义静态实例变量 在返回实例方法中初始化静态实例变量 线程安全（同步方法）懒汉式实现 优点：线程安全 缺点：同步整个方法的性能不高（每次返回实例都需要同步） 实现步骤：根据上述步骤，在返回实例的方法上添加同步关键字 同步代码块懒汉式实现 优点：效率比同步方法高 缺点：线程不安全（不能使用） 实现步骤：根据上述步骤，改为同步代码块实现返回实例的方法 双重校验实现 优点：懒加载、线程安全、性能高 缺点：JDK5之前的内存模型存在缺陷，无法使用volatile关键字完全避免指令重排序 实现步骤 构造器私有，同上 声明静态成员变量，并且添加volatile关键字修饰 获取实例的方法进行双重检查 静态内部类实现 优点：线程安全、懒加载（通过JVM静态内部类装载机制保证线程安全与懒加载） 缺点：无法防止反序列化创建对象 实现步骤 构造器私有，同上 写一个静态内部类，定义并且初始化实例变量 调用静态内部类的实例变量获取实例 枚举实现 优点：线程安全、防止反序列化创建对象、实现简单 缺点：不能懒加载 实现步骤 定义枚举 添加单例属性与自己的方法 简单（静态）工厂模式 优点：实现创建对象和使用分离（与客户端解耦） 缺点： 工厂类违反单一职责，负担过重 违反开闭原则，扩展复杂，需要修改代码 作用：封装创建多种对象、某一类对象的行为，避免添加新的产品类型而改动大量代码 类图：简单工厂持有抽象产品的引用，根据传入的产品类型选择实例化对象。 其他：不推荐使用，除非产品与工厂都十分简单 常见写法： 定义各类产品的抽象类 定义具体的产品类，并且继承其抽象类 定义工厂类 在构造方法中传入具体产品类型 根据产品类型new实例对象并且返回其抽象类型 需要生产产品的类中，通过聚合或者组合引用工厂对象，调用创建方法创建产品 工厂方法模式 优点： 能对客户端隐藏实现细节（最小知道（迪米特）原则） 允许抽象工厂通过多态（继承）灵活创建不同的对象，每种具体工厂负责单一产品（单一职责原则） 添加工厂与产品无需修改客户端、无需修改其他具体工厂和具体产品（开闭原则） 缺点： 抽象度高，理解与使用较难 类的数量很多，导致系统复杂，并且需要额外开销 作用：解决多种工厂导致类数量过多、将实例化的过程推迟到子类中，符合开闭原则。 类图：产品与工厂都是抽象类，它们都能扩展自己的子类。工厂依赖抽象产品；具体的工厂实现生产具体产品的方法，并且它依赖于具体的产品 其他：多种工厂对应多种产品的情况常见于针对特定类型的产品，添加特定的生产工厂。例如生产中国菜和日本菜，材料不同，菜式不同、厨房也不同，但是厨房生产菜的抽象是不变的，因此需要生产额外地区的菜，只需要添加新的菜式和厨房即可。比如新添加泰国菜和泰国厨房。如果结合简单工厂可以让中国厨房生产粤菜、湘菜，实现一个具体的工厂生产多种具体的产品，但是这样就违背了开闭原则，可以通过抽象工厂实现而不违背开闭原则。 常见写法： 创建抽象工厂类，定义工厂的生产方法 创建抽象产品类，定义抽象产品方法 创建具体产品类，继承抽象产品类，实现产品的抽象方法 创建具体工厂类，继承抽象工厂类，实现生产的抽象方法 调用方通过调用具体工厂类，产生不同的具体产品 抽象工厂模式 优点： 对客户端隔离了类的生成（最小知道（迪米特）原则） 增加产品族（某种品牌的工厂）时，符合开闭原则 对需要使用同一产品族（同一个品牌）的情况有利（例如：组装电脑的所有配件都选用英特尔，而不是CPU选英特尔，显卡选英伟达） 缺点：由于开闭原则具有倾斜性（会让某一方更加容易开闭），增加新的产品等级（新产品），会导致所有具体工厂都需要添加新产品的生产方法，违背了开闭原则 作用：用于产品等级结构稳定，产品族变动的情况。（生产产品的种类固定，但是品牌不同） 类图： 其他：抽象工厂最好用于产品种类固定的情况 原型模式 优点：简化创建过程（避免反复Get与Set被复制对象的值） 缺点：通过重写克隆方法实现原型模式，不符合开闭原则 作用：灵活的克隆简单对象 类图： 实现方法： 自己定义一个抽象原型类，包含一个抽象的克隆方法，需要克隆的类继承该类并且实现克隆方法。在方法中创建一个新对象，并且把属性值都重新赋值到新对象上，最后返回新对象 通过实现Cloneable接口并且重写Object类中的clone方法。在方法中调用super.clone()，最终强转回具体的对象返回 浅拷贝 特点：复制基础类型的值，无法复制引用对象，引用对象只复制引用值（指针） 实现方法：同上 深拷贝 特点：复制所有属性，包含引用对象 实现方法： 上述使用super.clone()方法只能浅拷贝，需要自己手动复制引用对象，通过引用对象也实现clone方法，调用引用对象的clone方法，返回引用对象，再赋值到当前要深拷贝的对象中，最后返回深拷贝对象 使用序列化。首先，对象必须实现Serializable接口，然后通过序列化与反序列化进行深拷贝 原型管理器：将多种原型（需要克隆的）对象用哈希表进行管理，相当于克隆对象的工厂，便于扩展原型对象，类图如下： 建造者模式 优点： 分离复杂对象的创建流程，让对象与对象的创建过程解耦 能用相同的创建流程创建不同的对象，精细的控制创建复杂对象的过程 通过抽象建造者充当缓冲层，具体建造者之间相互隔离，便于替换或添加新的具体建造者，符合开闭原则 缺点： 对于产品之间差异过大的情况，不适合使用，适用范围受限 对于产品内部复杂、细微差异过多的情况，会导致具体建造者过多，不利于维护与阅读 作用：将复杂对象与它的构建分离，让同样的构建过程创建不同的对象 类图： 抽象建造者（Builder）：负责规定返回产品的方法、创建产品部件包含的方法 具体建造者（ConcreteBuilder）：实现创建产品部件的方法，定义部件的装配过程，可有选择的重写返回产品的方法 产品（Product）：被构建的复杂对象，包含多个部件。 指挥者（Director）：在construct方法中定义不同部件（属性）的建造次序（例如盖房子，顺序为先打地基，再砌墙，最后盖屋顶），可以定义多个construct来控制组件的建造顺序（变为先砌墙，再打地基，最后盖屋顶），最后返回构建完毕的产品。如果对象组装简单，可以省略指挥者类，将构造方法置于抽象建造者中；如果对象组装复杂，可以用钩子函数决定是否组装某些组件（类似于模板方法模式） 使用场景： 产品之间相似度高（例如配件相似、组装流程相似） 产品的创建十分复杂，需要自由控制创建流程 希望产品的创建过程独立于创建该对象的类、用相同的创建过程创建不同的产品 实现方法： 编写产品类，确定产品具有哪些组件（属性） 编写抽象建造者，初始化一个产品对象成员变量，定义产品相似的部分、定义返回产品的方法 编写具体建造者，创建并且设置产品成员变量的属性（例如：产品成员变量是车，包含发动机、轮胎，此处确定产品具体的部分使用什么组件，使用大马力发动机与防滑轮胎）、实现返回产品（可选） 编写指挥者类，通过construct方法，根据不同的具体建造者，确定产品的装配流程（确定是先组装轮胎还是先组装发动机），返回产品 编写客户端，定义具体的建造者与指挥者，传入具体建造者的类型给指挥者，然后调用指挥者的construct方法生产产品 结构型：让类或对象之间组织成更加灵活、强大的结构 适配器模式 名词解释：目标类——客户端需要用的接口或方法（想要通过调用已有接口或方法来实现的接口或者方法）、适配者——被适配的类（已完成的接口或方法） 优点： 通过适配与兼容来重用某些已有的接口，提高了代码的复用性 将目标类与适配者分离，降低了代码耦合热望 添加适配器类时，符合开闭原则 对于对象适配器，可以适配多个适配者（持有多个适配者的成员变量）；根据里氏替换原则，可以适配适配者（被适配的类）的子类 缺点： 适配者类不能为final类 对于类适配器，Java等单继承的语言， 一次只能适配一个适配者 目标类只能为接口，有一定的局限性 对于对象适配器，修改适配者的方法复杂（可以通过实现一个适配者的子类，修改方法后，替换适配器中持有的成员变量为该子类对象） 作用：通过适配器来兼容不同的接口，使得它们能协同工作 适配器分类 类适配器：继承适配者，实现目标类中需要的方法或者接口 对象适配器：依赖适配者（适配器类中持有适配者成员变量），继承或者实现目标类 单接口（缺省）适配器：通过抽象类空（默认）实现接口中的方法，子类可以有选择的重写这些空方法 双向适配器：在对象适配器中，持有目标类与适配者的成员变量 使用场景： 已有的接口和想要的新接口功能几乎相同，只是规格不同（比如换算单位不一样，电压标准不同等等） 创建可重复使用的类，这个类作为那些没有太大关联的类（包括以后要添加的类）的桥梁 桥接模式 优点： 分离抽象接口与实现部分。通过关联关系代替继承关系，让抽象和实现能够根据各自的维度独立变化，由不同维度组合出不同功能的对象 减少了继承层级，减少了子类数量 扩展不同维度中独立变化的部分，只需要添加对应维度的子类即可，符合开闭原则 缺点： 正确的识别类的不同维度的变化比较困难，需要十分有经验 需要在设计阶段就进行抽象分析，增加了系统的设计与理解难度 作用：将抽象部分与它的实现部分解耦，让两者能够独立变化 类图： 使用场景： 避免不同维度的变化通过静态的继承关系实现，想要在抽象层建立中关联关系 系统希望对抽象角色与具体角色动态耦合（即将抽象对象的子类与实现对象的子类通过关联关系进行动态组合） 一个类存在多种独立变化的维度，并且每种维度都希望能够独立扩展 对于使用多层继承会造成类数量的过多的系统 编写步骤： 编写抽象类，通过构造方法注入具体实现接口的成员变量，并且在抽象类中定义抽象方法 编写具体实现接口，定义（需要独立变化与扩展的）业务方法 编写具体实现接口的实现类，实现上述的业务方法 编写细化（扩展）抽象子类，实现抽象类中定义的抽象方法。此时，可以调用父类中具体实现接口的成员变量中的方法，完成对不同维度功能的组合 编写客户端，定义抽象引用和具体实现接口引用，创建不同的抽象细化类与具体接口实现类，将具体接口实现类Set到抽象细化类中，便可以组合出具有不同功能的对象 装饰模式 优点： 扩展对象的功能比继承更加灵活，减少了继承层次，不会导致类爆炸 能够动态扩展对象的功能，实现不同行为（例如：读取配置文件，选择不同的具体装饰类） 对透明装饰模式，可以多次装饰某个对象，排列组合得到不同行为与功能的对象 具体组件类与具体装饰类互相独立，符合开闭原则 缺点： 因为不同的修饰方式可以产生功能不同的对象，所以会导致系统存在很多小对象，它们的区别仅仅是组合、连接的方式不同，不是类或者属性的不同，小对象过多会影响系统性能 对于被多次装饰的对象，不利于排查错误 作用：动态的给某个对象添加额外的职责，提供比继承更加灵活的扩展方式 分类： 透明装饰模式： 客户端全部使用抽象组件接收实例化的部分 可以对组件多次装饰（因为都是抽象组件的子类，并且通过构造方法实例化抽象组件成员变量） 客户端没办法调用具体装饰器中新增的方法（因为抽象组件中没有定义这些方法） 半透明装饰模式： 客户端可以使用抽象组件接收具体组件，但是只能用具体装饰器引用接收具体装饰器的实例，从而能够调用具体装饰器中的新增方法 不能多次装饰具体组件，只能装饰一次 类图：图中为透明装饰模式，若为半透明装饰模式，则具体组件只能被装饰一次，并且可以单独调用被添加（用于装饰对象）的方法 使用场景： 不影响其他对象实例，只想对某个对象实例动态、透明的添加职责 无法使用继承或继承不利于系统维护与扩展时，可以通过装饰模式来扩展功能（例如：Java中的final类、继承层次过多等） 编写方法： 编写抽象组件类，定义抽象方法（需要被修饰、增强的方法） 编写具体组件类，继承抽象组件类 编写装饰类，继承抽象组件类，在类中添加抽象组件的成员变量，通过构造器实例化抽象组件的成员变量 在装饰类中，重写抽象方法时，调用成员变量的抽象方法 编写具体装饰类，继承装饰类，构造方法调用中调用装饰类的构造方法，传入抽象组件对象 在具体装饰类中，重写抽象方法时，调用成员变量的抽象方法（原本的业务方法），调用自身新增的业务方法 编写客户端类，创建具体组件对象，传入具体装饰对象的构造方法中， 若为透明装饰模式，则可以都用抽象组件引用接收对象并使用，并且可以多次装饰，没有办法调用被装饰后新增的业务方法 若为半透明装饰模式，则定义具体组件可以用抽象组件的引用接收，被装饰的对象只能用具体装饰器接收，此时可以调用具体装饰对象的新增业务方法 组合模式 优点： 能够清楚地定义层次关系，客户端可以忽略层次的不同进行操作 透明组合模式下，由于客户端能够一致的使用叶子构件和容器构件的方法，所以能简化调用代码 添加叶子构件或者容器构件都十分方便，无需改动现有代码，符合开闭原则 不仅对树形结构的控制简单，而且能够通过叶子构件与容器构件递归组合，实现复杂的树形结构 缺点： 添加新的构件类型，容易产生过多的类 如果希望某个容器下只允许某种叶子构件，需要编写代码约束，十分复杂（不然客户端给A容器添加C容器的C叶子节点，而本来A容器应该添加A叶子节点） 作用：组合多种对象，形成树形结构，表示部分-整体的层次结构。组合模式能统一操作叶子节点与父节点，无需关心它们的区别 分类： 透明组合模式：调用叶子构件与容器构件都一样，但是调用叶子构件会产生异常，没有进行处理会出错 安全组合模式：抽象构件中不提供操作子节点的方式，这样客户端无法统一对叶子构件和容器构件编程，不会出现抛不支持操作异常的情况 类图： AbstracComponent：抽象构件，可以是抽象类或者接口，为叶子节点（叶子构件）与父节点（容器构件）声明通用操作的接口 Composite：容器构件，实现抽象构件中的接口，使用集合存储它所管理的叶子节点列表，并且可以递归调用子节点的方法，直到调用时遇到叶子节点为止 Leaf：叶子构件，它没有子节点，实现抽象构件中的部分接口，如果调用了它未实现的操作方法，则可以抛出异常（例如：调用叶子节点增加子节点的方法，可以抛出不支持该操作的异常） 使用场景： 具有部分与整体的层次结构，并且希望客户端统一管理部分与整体 希望在面向对象语言中处理树形结构，并且节点具有相似的方法 系统可以分离出叶子构件与容器构件，并且它们的类型数量不确定，希望随时扩充新类型(Swing包中的Panel(容器)和Button(叶子)等GUI编程) 编写方法： 编写抽象构件类：定义通用的子节点管理抽象方法(增删改查子节点)，定义需要实现的抽象业务方法 编写容器构件类：继承或者实现抽象构件中的方法，编写一个抽象构件集合，用于存储当前容器所管理的子构件列表 编写叶子构件类：继承或实现抽象构件中的方法 编写客户端，定义抽象构件的引用，实例化容器构件与叶子构件，将叶子构件添加到容器构件中，再调用容器构件的业务方法 外观模式 优点： 子系统内部的变化不影响外观对象 客户端只需要依赖外观对象，不需要关联子系统的各种对象，降低了耦合，让子系统更加容易使用 子系统内部的变化不影响客户端对其使用 缺点： 客户端可能绕过门面类直接访问子系统，想要避免这种情况会减低子系统的灵活性与可变性 如果门面类设计有缺陷，后期新增子系统或者新增门面功能会导致门面类代码变动，不符合开闭原则 作用：作为子系统接口调用的统一入口，方便使用子系统 类图： 使用场景： 为客户端提供多种复杂子系统的统一API调用入口 客户端与子系统的耦合很强，通过引入外观类进行解耦 在多层结构中，通过外观类定义每层的入口，由外观类进行层与层之间的通信，降低了层之间的耦合度 编写方法： 编写抽象外观类，定义通用的抽象方法 编写子系统类（单例类、工厂类等），实现该子系统负责模块的方法 编写具体外观类继承抽象外观类，定义具体外观类中需要用到的子系统成员变量，调用并且组合子系统中的模块方法实现父类的抽象方法 创建客户端类，定义抽象门面类的引用，实例化具体门面类，调用通用的抽象方法 享元模式 优点： 重复利用（相同或相似的）细粒度对象，节省系统资源 区分了对象的外部状态与内部状态，它们相互独立，使得具有不同外部状态的对象可以共享相同的内部状态对象（例如：棋子的位置对象[外部状态]与黑色或白色棋子对象[内部状态]，可以通过设置不同的位置坐标，传入黑棋或者白棋，黑棋或白棋对象则只会产生一个） 缺点： 分离了内部状态与外部状态，使得对象变得复杂，对对象的操作也会复杂 由于分离了内部与外部状态，那么读取这个对象对应的外部状态需要耗费更长的时间 作用：运用共享技术复用大量细粒度的对象 类图：使用单例模式创建共享的享元对象以及享元工厂；使用组合模式组合共享的享元对象与不共享的享元对象；使用享元模式对共享的对象进行缓存，而不是重复创建（此图为复合享元模式的类图） 分类 单纯享元模式：只存在可以共享的享元类，没有不可共享的享元类，即只有上图的ConcreteFlyweight类、AbstractFlyweight类、FlyweightFactory类 复合享元模式：使用组合模式组合了不可共享的类 使用场景： 系统中存在大量相同或者相似的对象 某种对象的大部分状态可以分为不变与变化的，将变化的状态封装成不共享的对象，不变的状态进行缓存 由于使用缓存池缓存享元对象，会耗费系统资源，所以享元对象应该被频繁使用，避免浪费资源 代理模式 优点： 通过代理对象协调调用者与被调用者，降低了它们之间的耦合度 客户端使用代理对象进行编程，所以修改被代理对象的代码时，客户端无需修改代码，符合开闭原则 使用远程代理时，可以将运算复杂的业务放置在高性能服务器中，提升了系统整体的运行效率 使用虚拟代理时，可以懒加载某些需要庞大性能的对象，节省了系统资源 使用缓冲代理时，可以对运算结果进行临时缓存，共享给后续运算步骤，优化了系统性能 使用保护代理时，可以控制对象的访问权限，给不同的客户端分配不同的使用权限 缺点： 由于多了代理层，可能会造成业务处理速度降低（例如：保护代理，需要进行权限检查，而权限检查需要耗费系统资源） 某些代理模式的实现方式十分复杂（例如：Java中的RMI（远程代理），需要序列化对象，反序列化对象等一系列操作） 作用：提供某个对象的代理对象，由代理对象来控制对原来对象的访问 分类： 远程代理：使得客户端能使用远程服务器中的方法 虚拟代理：对加载时间长的对象，先使用“虚假”的代理对象来代表真实对象，等真实对象加载完毕后，虚拟代理将请求转发给真实对象 静态代理：代理类和被代理类都必须继承或实现相同的父类或接口，代理类持有被代理类的成员变量，并且重写父类方法，调用被代理类中相同的方法（这样会导致代理类的数量过多） JDK动态代理：能够在系统运行时，根据需要动态的创建代理类，使得同一个代理类能代理多个不同的被代理类，常用于事务管理、AOP编程等（被代理的对象必须实现或继承它原本的父类或接口） CGLIB(Code Generation Library)动态代理：与JDK动态代理相比，被代理的类也不需要实现接口或者继承父类 保护代理：对于某些敏感的对象，在调用前，代理对象会检查客户是否具有权限，没有权限则不允许调用 缓冲代理：对于计算量较大的对象，通过在客户端或者服务端创建缓冲代理对象，避免每次调用都进行重复计算 智能引用代理：代理对象内部计数器计算调用次数，当没有使用者调用时，则该自动释放该代理对象 类图：下图为静态代理模式的类图，代理对象与被代理对象都必须实现相同的接口，代理对象可以在调用被代理对象方法的时候，进行一些额外的操作 使用场景： 客户都安需要访问远程服务器中的对象，可以使用远程代理 可以通过虚拟代理缩短系统的启动时间 对频繁访问的计算结果，使用缓冲代理进行缓存 需要对调用方进行权限控制，可以使用保护代理 需要为某个对象的引用提供额外功能时，可以使用智能引用代理（例如：某个对象的引用次数为0，则可以释放该对象） 行为型：关注方法层面的调用 模板方法模式 优点： 抽象出公共步骤，复用了代码 子类实现具体的细节，便于替换与扩展算法实现 类的行为由父类控制，子类负责实现 缺点： 修改骨架十分困难 会导致类数量过多 作用：定义一系列的算法步骤，将实现延迟到子类，使得子类能够不改变算法的整体结构，重新定义某些特定的算法步骤 类图：子类通过重写钩子方法可以决定是否执行某些算法步骤 使用场景： 需要控制子类的扩展，以符合算法规则 不同的类中，存在相同的业务流程，出现大量重复代码 命令模式 优点： 实现请求的调用者与请求的执行者解耦 可以实现不同的命令子类，扩展性好 缺点：会导致类的数量过多 作用：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。 类图：通过栈保存命令调用的历史，以此达到撤销命令，还可以结合组合模式执行宏命令（一系列的命令批量执行） 使用场景： 需要撤销多次处理 实现原子事务（出现异常需要回滚） 命令含义稳定，并且希望解耦命令的调用者与执行者 访问者模式 优点： 增加新的访问者（访问操作）十分方便，满足开闭原则 将访问的行为内聚到访问者对象中，让类的职责更清晰，使得复杂对象可供多个不同的访问者访问 不修改结构层次关系，却能对层次添加操作 缺点： 新增具体元素类，不符合开闭原则，每个访问者对象都需要进行修改 访问者访问的元素必须暴露某些内部操作、状态供其使用，破坏了对象的封装性 作用：对操作复杂对象中的不同部分，在改变原有类的前提下，提供不同的操作方法 类图： 使用场景： 一个复杂对象中，存在多种不同的对象，希望根据不同的访问者对这些对象进行不同的操作 复杂对象的结构稳定，并且需要经常为其添加新的操作方式 希望对复杂对象的访问操作分离，避免大量的操作方式让复杂对象过于臃肿 迭代器模式 优点： 将遍历对象与存储对象分离，使得遍历时无需知道其内部结构，降低了耦合性 通过实现不同的迭代器可以替换遍历算法，并且为不同对象的遍历提供了统一的编程方式 对某个聚合对象添加新的遍历算法，只需要实现新的迭代器，符合开闭原则 缺点： 实现不同的遍历器类会导致类数量过多(可以通过内部类实现解决) 对遍历器接口的设计要求很高，若要修改遍历接口，则不符合开闭原则 遍历时，不能修改被遍历的集合，否则会遍历出错 作用：提供一种方法访问聚合对象，而无需知道其内部结构 类图：使用内部类来实现具体迭代器类 使用场景： 访问某个对象的元素而无需暴露其内部结构 需要为某个对象提供多种遍历方式 为不同对象的遍历方式提供统一的遍历操作接口，使得客户端能够统一遍历方式 观察者模式 优点： 将表示层与数据层分离，使得不同层次的对象都可以充当观察者 观察者与被观察者通过抽象耦合，它们无需知道对方具体的实现细节，便可以与对方进行通信 简化了一对多的广播通信等系统的设计难度 增加新的具体观察者符合开闭原则；当观察者与被观察者没有关联时，新增被观察者也十分方便 缺点： 观察者过多，会导致推送更新的时间过长 若观察者和被观察的对象之间存在循环依赖，则观察者模式会触发死循环 观察者无法知道是什么原因导致被观察的目标发生变化 作用：定义对象之间的一对多关系，使得一个对象的状态发生改变，它的观察者都能收到通知并且更新自身持有的信息 类图： 使用场景： 存在两个抽象的模型，且一方依赖于另外一方，则可使用观察者模式在抽象层进行关联，使得它们能够独立的改变与复用 一个对象的改变需要通知其他对象也发生改变，并且不知道这些对象的类型与数量 可以使用观察者模式形成触发链 中介者模式 优点： 将对象间多对多的关联关系转换成一对多的关联关系，简化了编程的复杂度，更容易维护与理解、扩展 解耦具体同事类之间的关联关系，使得它们能够相互独立变化，符合开闭原则 具体同事类可以被子中介者类复用，降低了类的数量 缺点：中介者类中包含大量同事类的交互逻辑，难以维护，容易出错 作用：用一个中介对象封装一系列对象的交互，使这些对象无需显示引用对方，从而降低它们的耦合，让它们能独立变化 类图：同事类One和Two，通过中介者类进行通信。中介者根据具体的同事类，决定执行如何调用其他同事类 ![Package intermediary](/assets/Package intermediary.png) 使用场景： 系统中的对象存在复杂的引用关系，系统结构混乱并且难以理解 某个对象引用了许多对象，并且与这些对象进行交互，并且希望能复用它 希望通过一个中间类封装多个类中的行为，又不希望创建过多的中间类 备忘录模式（对象行为模式） 优点： 提供对象状态恢复的机制，可用于对象变更成新状态遇到问题时，恢复老状态 通过栈等其他数据结构存储实现，可进行多次撤销操作，即使执行时状态产生了分支，也能回退 缺点：当状态对象过于复杂时，使用备忘录对象保存状态会造成过多的内存开销（需要只记录每次修改变动的部分解决此问题，但其实现将十分困难） 作用：不破坏对象内部封装的前提下，保存其内部状态到其他对象中，当需要恢复状态的时候进行恢复 类图：通过内部类和栈实现多步回退机制 使用场景： 需要保存某一时刻某个对象的所有状态，以便于后续进行恢复 希望将状态对象的变更历史保存到它自己当中，不希望其他对象修改它的变更历史 解释器模式（类行为模式） 优点： 能够轻松实现简单的文法规则，新增文法规则只需要添加新的实现类，符合开闭原则 具体节点类之间存在相似的结构，可以使用工具自动生成相关代码 缺点： 复杂的文法类的数量会过多 执行效率不高（因为解释复杂句子时，存在大量递归与循环调用，并且难以理解与调试） 作用：定义一种语言文法，编写对应的解释器对其进行翻译，执行其具体含义 类图：定义抽象节点（BaseNode）、中间语法节点（ExpressionNode、CommandNode）、语法叶子节点（NonLoopNode、LoopNode），其中表达式节点由多个命令节点组成，命令节点由多个循环或者不循环叶子节点组成，最后通过上下文（Context类）携带的句子信息，使用ExpressionNode节点进行翻译与执行命令 ![Package interpreter](/assets/Package interpreter.png) 使用场景： 执行效率要求不高，需要进行简单的文法转换 可以用简单文法描述的重复问题（例如：二维平面的移动，确定方向与距离，多次执行命令，便可以到达任何位置） 状态模式（对象行为模式） 优点： 将状态代码与状态对象解耦，便于集中管理控制状态的相关代码 持有不同的状态对象，可以具有不同的功能实现方式 可以通过环境对象共享状态对象，减少所需的具体状态类 缺点： 由于分离了环境对象与其状态，当状态的种类较多时，会产生较多的具体状态类 增加新状态需要修改那些负责转换状态的类，不符合开闭原则 分离状态代码会导致代码的设计难度提升 作用：使得对象的内部状态发生改变，其行为也随之改变 类图：可通过状态类控制状态转换，也可以通过上下文类自身进行状态的控制，还可以通过静态状态成员变量在上下文对象间进行状态共享 ![Package state](/assets/Package state.png) 使用场景： 对象的行为依赖自身的属性值 模块中存在大量处理、维护状态的语句 策略模式（对象行为模式） 优点： 完全符合开闭原则，可以不修改原有的代码进行新增、修改算法 通过抽象策略类可以复用公共的算法代码，并且具体策略也可以被其他上下文类复用 允许在运行时切换具体的算法实现，并且支持每种不同的算法独立扩展与修改 能够避免大量分支语句块的出现 缺点： 客户端需要理解每种不同的算法，当算法种类过多时，学习成本较大 任何算法的变化都会新增具体策略类，会造成具体策略类过多 无法混用多种策略（比如使用A策略类的前三步，再用B策略类的后三步完成业务处理） 作用：定义一系列的算法，由具体子类实现不同的算法，将这些算法封装起来，使得它们可以相互替换 类图： 使用场景： 模块的运行需要动态切换成某种不同的算法逻辑 业务逻辑存在大量分支语句，存在多重条件选择语句（例如 A &amp;&amp; B &amp;&amp; C），可以通过策略分发的方式消除 不希望客户端知道算法的具体实现逻辑 责任链（职责链）模式（对象行为模式） 分类: 完全（纯职责）职责模式： 请求只能被职责链中的某一个环节处理，不能继续转发至其他节点 不能出现请求没有节点处理的情况 不完全（不纯）职责模式： 请求被某个节点处理后，可以继续传递给后续节点进行处理 可以出现请求没有被任何节点处理的情况 优点： 请求对象与处理对象进行解耦，职责链由客户端创建，降低系统的耦合度 每一位请求处理者只需要维持后一位处理者的引用，而无需知晓全部处理者 可以在运行时修改职责链，从而动态改变处理流程 新增处理节点时，符合开闭原则 缺点： 请求可能会因为职责链的配置错误而无法正确处理 职责链过长，处理性能会受影响，并且调试难度增加 作用：将请求发送者与请求处理者分离（由多个处理对象组成一条处理链，请求沿着链条传递，直到有对象能对请求进行处理） 类图： ![Package chain](/assets/Package chain.png) 使用场景： 多个对象都能处理一个请求，并且需要运行时才确定使用哪个对象进行处理，客户端不关心具体处理请求的对象 想要动态改变请求处理者的先后顺序、处理者的数量等职责链相关的属性","categories":[{"name":"编程内功","slug":"编程内功","permalink":"https://b727031867.github.io/categories/%E7%BC%96%E7%A8%8B%E5%86%85%E5%8A%9F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://b727031867.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://b727031867.github.io/categories/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://b727031867.github.io/categories/Spring/"},{"name":"编程内功","slug":"编程内功","permalink":"https://b727031867.github.io/categories/%E7%BC%96%E7%A8%8B%E5%86%85%E5%8A%9F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://b727031867.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://b727031867.github.io/tags/Spring/"},{"name":"设计模式","slug":"设计模式","permalink":"https://b727031867.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}