---
title: 设计模式
date: 2021-04-29 10:41:10
categories:
- 编程内功
tags:
- 设计模式
---
# 设计模式学习笔记

- ## 七大设计原则

1. ### 单一职责原则：一个类只负责一项职责

   作用：防止修改代码时，影响其他功能，降低类之间的耦合

   注意：逻辑简单，可以违背类级别的单一职责，即一个类包含多个功能，但是，最低要保证方法的职责单一

2. ### 接口隔离原则：类只依赖所需的最小接口

   作用：避免实现自身用不到的方法、降低耦合，提高代码阅读性

   特点：把通用的方法抽取到更小的接口中，类实现多个小接口来满足自身的需要

3. ### 依赖倒置（倒转）原则：抽象不依赖细节，细节依赖抽象

   作用：让代码更加稳定，减少修改的可能性（抽象层较为稳定）；通过接口与抽象类编写规范，交给实现类完成功能。

   特点：面向接口编程，通过传递接口参数，根据具体实现类的不同而完成不同的功能。相当于通过接口进行耦合，避免了类与类之间的强耦合。

4. ### 里氏替换原则：能用父类的位置都能用子类替换

   作用：减少继承的使用，通过聚合、组合、依赖三种类的关系来取代继承；防止子类无意中重写父类方法，而导致程序出错（如果子类重写了父类方法，将调用子类的实现方法，可能导致与原来不同的结果）

   特点：子类尽量不重写父类方法，运用父类的位置可以替换成子类。

5. ### 开闭原则：对扩展开放，对修改关闭

   作用：能够避免修改代码，灵活扩充功能（是使用设计模式的最终目标，上述原则作为此原则的铺垫）

   特点：使用（调用）方无需修改代码，提供方可以通过添加抽象方法直接添加功能（由子类实现功能）

6. ### 迪米特原则（最小知道原则）：类对依赖的类知道的越少越好

   作用：降低类之间的耦合

   特点：只和直接关联的类通信，类自身的逻辑应该由自身内部完成，对外只提供公开方法

   直接关联的类：成员方法、方法参数、返回值用到的类（**局部变量使用的类*不属于***）

7. ### 合成复用原则：少用继承，多用组合、聚合代替继承

   特点：通过少用继承，多用依赖的方式降低类之间的耦合度

- ## UML

    - 作用：统一建模语言，用于描述软件模型中各个元素之间的关系
    - 分类
        - 动态图：
            1. 序列图
            2. 协作图
            3. 状态图
            4. 活动图
        - 静态图：
            1. 用例图
            2. 类图
            3. 对象图
            4. 包图
            5. 构件图
            6. 部署图



- ## 类关系

    1. 依赖关系：类中使用了其他类（范围最大），则它们存在依赖关系

       ![image-20200619141549656](/assets/image-20200619141549656.png)

    2. 关联关系：具有方向性，用于表示对象间的数量关系（1：1、1：n、n：n）

       ![image-20200619141508154](/assets/image-20200619141508154.png)

    3. 聚合关系：整体与部分**可以分割**（例如：你与你的电脑，电脑可有可无）

       ![image-20200619141441647](/assets/image-20200619141441647.png)

    4. 组合关系：整体与部分**不可分割**——同生共死（比如脸上含有眼睛、嘴巴等）

       ![image-20200619141447983](/assets/image-20200619141447983.png)

    5. 泛化关系：依赖关系的特例，表示继承关系

       ![image-20200619141602834](/assets/image-20200619141602834.png)

    6. 实现关系：依赖关系的特例，表示它与它实现接口的关系

       ![image-20200619141615840](/assets/image-20200619141615840.png)

## 23种设计模式

![image-20200619143149221](/assets/image-20200619143149221.png)

1. ### 创建型：用于对象创建管理

    - #### 单例模式

      作用：确保重量级对象只返回一个实例，避免资源浪费、并发问题；对于频繁创建与销毁对象的情况，可以提高性能

      **常见写法：**

        1. #### 饿汉式

            - 静态常量饿汉式实现：

                1. 优点：实现简洁，通过类装载机制保证线程安全

                2. 缺点：无法懒加载，可能浪费内存

                3. 实现步骤：

                    - 构造方法私有

                      ![image-20200619183637492](/assets/image-20200619183637492.png)

                    - 静态成员变量new自身（无法懒加载）

                      ![image-20200619183620617](/assets/image-20200619183620617.png)

                    - 提供公有静态方法获取成员实例

              ![image-20200619183711499](/assets/image-20200619183711499.png)

            - 静态代码块饿汉式实现

              只是把上述new的过程放入静态代码块实现，优缺点、步骤同上

              ![image-20200619191803962](/assets/image-20200619191803962.png)

        2. #### 懒汉式

            - 线程不安全懒汉式实现

                1. 优点：懒加载

                2. 缺点：线程不安全（不建议使用）

                3. 实现步骤

                    - 构造器私有

                      ![image-20200619192025316](/assets/image-20200619192025316.png)

                    - 定义静态实例变量

                      ![image-20200619192033415](/assets/image-20200619192033415.png)

                    - 在返回实例方法中初始化静态实例变量

                      ![image-20200619192042676](/assets/image-20200619192042676.png)

            - 线程安全（同步方法）懒汉式实现

                1. 优点：线程安全

                2. 缺点：同步整个方法的性能不高（每次返回实例都需要同步）

                3. 实现步骤：根据上述步骤，在返回实例的方法上添加同步关键字

                   ![image-20200619193647024](/assets/image-20200619193647024.png)

            - 同步代码块懒汉式实现

                1. 优点：效率比同步方法高

                2. 缺点：**线程不安全**（不能使用）

                3. 实现步骤：根据上述步骤，改为同步代码块实现返回实例的方法

                   ![image-20200619193914779](/assets/image-20200619193914779.png)

        3. #### 双重校验实现

            1. 优点：懒加载、线程安全、性能高

            2. 缺点：**JDK5之前**的内存模型存在缺陷，无法使用volatile关键字完全避免指令重排序

            3. 实现步骤

                - 构造器私有，同上

                - 声明静态成员变量，并且添加**volatile**关键字修饰

                  ![image-20200619195741899](/assets/image-20200619195741899.png)

                - 获取实例的方法进行双重检查

                  ![image-20200619195818520](/assets/image-20200619195818520.png)

        4. #### 静态内部类实现

            1. 优点：线程安全、懒加载（通过JVM静态内部类装载机制保证线程安全与懒加载）

            2. 缺点：无法防止反序列化创建对象

            3. 实现步骤

                - 构造器私有，同上

                - 写一个静态内部类，定义并且初始化实例变量

                  ![image-20200619200843174](/assets/image-20200619200843174.png)

                - 调用静态内部类的实例变量获取实例

                  ![](/assets/image-20200619201012758.png)

        5. #### 枚举实现

            1. 优点：线程安全、防止反序列化创建对象、实现简单

            2. 缺点：不能懒加载

            3. 实现步骤

                - 定义枚举

                  ![image-20200619201510225](/assets/image-20200619201510225.png)

                - 添加单例属性与自己的方法

                  ![image-20200619202324162](/assets/image-20200619202324162.png)

    - #### 简单（静态）工厂模式

        1. 优点：实现创建对象和使用分离（与客户端解耦）

        2. 缺点：

            1. 工厂类违反单一职责，负担过重
            2. 违反开闭原则，扩展复杂，需要修改代码

        3. 作用：封装创建多种对象、某一类对象的行为，避免添加新的产品类型而改动大量代码

        4. 类图：简单工厂持有抽象产品的引用，根据传入的产品类型选择实例化对象。

           ![image-20200625124752962](/assets/image-20200625124752962.png)

        5. 其他：不推荐使用，除非产品与工厂都十分简单

      **常见写法：**

        1. 定义各类产品的抽象类
        2. 定义具体的产品类，并且继承其抽象类
        3. 定义工厂类
        4. 在构造方法中传入具体产品类型
        5. 根据产品类型new实例对象并且返回其抽象类型
        6. 需要生产产品的类中，通过聚合或者组合引用工厂对象，调用创建方法创建产品

    - #### 工厂方法模式

        1. 优点：

            1. 能对客户端隐藏实现细节（最小知道（迪米特）原则）
            2. 允许抽象工厂通过多态（继承）灵活创建不同的对象，每种具体工厂负责单一产品（单一职责原则）
            3. 添加工厂与产品无需修改客户端、无需修改其他具体工厂和具体产品（开闭原则）

        2. 缺点：

            1. 抽象度高，理解与使用较难
            2. 类的数量很多，导致系统复杂，并且需要额外开销

        3. 作用：解决多种工厂导致类数量过多、将实例化的过程推迟到子类中，符合开闭原则。

        4. 类图：产品与工厂都是抽象类，它们都能扩展自己的子类。工厂依赖抽象产品；具体的工厂实现生产具体产品的方法，并且它依赖于具体的产品

           ![image-20200620121517991](/assets/image-20200620121517991.png)

        5. 其他：多种工厂对应多种产品的情况常见于针对特定类型的产品，添加特定的生产工厂。例如生产中国菜和日本菜，材料不同，菜式不同、厨房也不同，但是厨房生产菜的抽象是不变的，因此需要生产额外地区的菜，只需要添加新的菜式和厨房即可。比如新添加泰国菜和泰国厨房。**如果结合简单工厂可以让中国厨房生产粤菜、湘菜，实现一个具体的工厂生产多种具体的产品，但是这样就违背了开闭原则，可以通过抽象工厂实现而不违背开闭原则。**

      **常见写法：**

        1. 创建抽象工厂类，定义工厂的生产方法
        2. 创建抽象产品类，定义抽象产品方法
        3. 创建具体产品类，继承抽象产品类，实现产品的抽象方法
        4. 创建具体工厂类，继承抽象工厂类，实现生产的抽象方法
        5. 调用方通过调用具体工厂类，产生不同的具体产品

    - #### 抽象工厂模式

        1. 优点：

            1. 对客户端隔离了类的生成（最小知道（迪米特）原则）
            2. 增加产品族（某种品牌的工厂）时，符合开闭原则
            3. 对需要使用同一产品族（同一个品牌）的情况有利（例如：组装电脑的所有配件都选用英特尔，而不是CPU选英特尔，显卡选英伟达）

        2. 缺点：由于开闭原则具有倾斜性（会让某一方更加容易开闭），增加新的产品等级（新产品），会导致所有具体工厂都需要添加新产品的生产方法，违背了开闭原则

        3. 作用：用于产品等级结构稳定，产品族变动的情况。（生产产品的种类固定，但是品牌不同）

        4. 类图：

           ![img](/assets/0_PFFZ4GGOKTH_OP6TAY}QE.png)

        5. 其他：抽象工厂最好用于产品种类固定的情况

    - #### 原型模式

        1. 优点：简化创建过程（避免反复Get与Set被复制对象的值）

        2. 缺点：通过重写克隆方法实现原型模式，不符合开闭原则

        3. 作用：灵活的克隆简单对象

        4. 类图：

           ![image-20200628221245858](/assets/image-20200628221245858.png)

        5. 实现方法：

            1. 自己定义一个抽象原型类，包含一个抽象的克隆方法，需要克隆的类继承该类并且实现克隆方法。在方法中创建一个新对象，并且把属性值都重新赋值到新对象上，最后返回新对象
            2. 通过实现Cloneable接口并且重写Object类中的clone方法。在方法中调用super.clone()，最终强转回具体的对象返回

        - **浅拷贝**

            1. 特点：复制基础类型的值，无法复制引用对象，引用对象只复制引用值（指针）
            2. 实现方法：同上

        - **深拷贝**

            1. 特点：复制所有属性，包含引用对象

            2. 实现方法：

            1. 上述使用super.clone()方法只能浅拷贝，需要自己手动复制引用对象，通过引用对象也实现clone方法，调用引用对象的clone方法，返回引用对象，再赋值到当前要深拷贝的对象中，最后返回深拷贝对象

            2. 使用序列化。首先，**对象必须实现Serializable接口**，然后通过序列化与反序列化进行深拷贝

            ![image-20200629111247527](/assets/image-20200629111247527.png)

        - **原型管理器**：将多种原型（需要克隆的）对象用哈希表进行管理，相当于克隆对象的工厂，便于扩展原型对象，类图如下：

          ![image-20200629112749121](/assets/image-20200629112749121.png)

    - #### 建造者模式

        1. 优点：

            1. 分离复杂对象的创建流程，让对象与对象的创建过程解耦
            2. 能用相同的创建流程创建不同的对象，精细的控制创建复杂对象的过程
            3. 通过抽象建造者充当缓冲层，具体建造者之间相互隔离，便于替换或添加新的具体建造者，符合开闭原则

        2. 缺点：

            1. 对于产品之间差异过大的情况，不适合使用，适用范围受限
            2. 对于产品内部复杂、细微差异过多的情况，会导致具体建造者过多，不利于维护与阅读

        3. 作用：将复杂对象与它的构建分离，让同样的构建过程创建不同的对象

        4. 类图：

            - 抽象建造者（Builder）：负责规定返回产品的方法、创建产品部件包含的方法

            - 具体建造者（ConcreteBuilder）：实现创建产品部件的方法，定义部件的装配过程，可有选择的重写返回产品的方法

            - 产品（Product）：被构建的复杂对象，包含多个部件。

            - 指挥者（Director）：在construct方法中定义不同部件（属性）的建造次序（例如盖房子，顺序为先打地基，再砌墙，最后盖屋顶），可以定义多个construct来控制组件的建造顺序（变为先砌墙，再打地基，最后盖屋顶），最后返回构建完毕的产品。如果对象组装简单，可以省略指挥者类，将构造方法置于抽象建造者中；如果对象组装复杂，可以用钩子函数决定是否组装某些组件（类似于模板方法模式）

              ![image-20200629172125977](/assets/image-20200629172125977.png)

        5. 使用场景：

            1. 产品之间相似度高（例如配件相似、组装流程相似）
            2. 产品的创建十分复杂，需要自由控制创建流程
            3. 希望产品的创建过程独立于创建该对象的类、用相同的创建过程创建不同的产品

        6. 实现方法：

            1. 编写产品类，确定产品具有哪些组件（属性）
            2. 编写抽象建造者，初始化一个产品对象成员变量，定义产品相似的部分、定义返回产品的方法
            3. 编写具体建造者，创建并且设置产品成员变量的属性（例如：产品成员变量是车，包含发动机、轮胎，此处确定产品具体的部分使用什么组件，使用大马力发动机与防滑轮胎）、实现返回产品（可选）
            4. 编写指挥者类，通过construct方法，根据不同的具体建造者，确定产品的装配流程（确定是先组装轮胎还是先组装发动机），返回产品
            5. 编写客户端，定义具体的建造者与指挥者，传入具体建造者的类型给指挥者，然后调用指挥者的construct方法生产产品

2. ### 结构型：让类或对象之间组织成更加灵活、强大的结构

    - #### 适配器模式

      #### 名词解释：目标类——客户端需要用的接口或方法（想要通过调用已有接口或方法来实现的接口或者方法）、适配者——被适配的类（已完成的接口或方法）

        1. 优点：
            1. 通过适配与兼容来重用某些已有的接口，提高了代码的复用性
            2. 将目标类与适配者分离，降低了代码耦合热望
            3. 添加适配器类时，符合开闭原则
            4. 对于对象适配器，可以适配多个适配者（持有多个适配者的成员变量）；根据里氏替换原则，可以适配适配者（被适配的类）的子类
        2. 缺点：
            1. 适配者类不能为final类
            2. 对于类适配器，Java等单继承的语言，
                1. 一次只能适配一个适配者
                2. 目标类只能为接口，有一定的局限性
            3. 对于对象适配器，修改适配者的方法复杂（可以通过实现一个适配者的子类，修改方法后，替换适配器中持有的成员变量为该子类对象）
        3. 作用：通过适配器来兼容不同的接口，使得它们能协同工作
        4. 适配器分类
            1. 类适配器：继承适配者，实现目标类中需要的方法或者接口

               ![image-20200701221920901](/assets/image-20200701221920901.png)

            2. 对象适配器：依赖适配者（适配器类中持有适配者成员变量），继承或者实现目标类

               ![image-20200701222101467](/assets/image-20200701222101467.png)

            3. 单接口（缺省）适配器：通过抽象类**空（默认）实现**接口中的方法，子类可以**有选择的**重写这些空方法

               ![image-20200701223134101](/assets/image-20200701223134101.png)

            4. 双向适配器：在对象适配器中，持有目标类与适配者的成员变量

               ![image-20200701224613210](/assets/image-20200701224613210.png)
        5. 使用场景：

            1. 已有的接口和想要的新接口功能几乎相同，只是规格不同（比如换算单位不一样，电压标准不同等等）
            2. 创建可重复使用的类，这个类作为那些没有太大关联的类（包括以后要添加的类）的桥梁

    - #### 桥接模式

        1. 优点：

            1. 分离抽象接口与实现部分。通过关联关系代替继承关系，让抽象和实现能够根据各自的维度独立变化，由不同维度组合出不同功能的对象
            2. 减少了继承层级，减少了子类数量
            3. 扩展不同维度中独立变化的部分，只需要添加对应维度的子类即可，符合开闭原则

        2. 缺点：

            1. 正确的识别类的不同维度的变化比较困难，需要十分有经验
            2. 需要在设计阶段就进行抽象分析，增加了系统的设计与理解难度

        3. 作用：将抽象部分与它的实现部分解耦，让两者能够独立变化

        4. 类图：

           ![image-20200710072024115](/assets/image-20200710072024115.png)

        5. 使用场景：

            1. 避免不同维度的变化通过静态的继承关系实现，想要在抽象层建立中关联关系
            2. 系统希望对抽象角色与具体角色动态耦合（即将抽象对象的子类与实现对象的子类通过关联关系进行动态组合）
            3. 一个类存在多种独立变化的维度，并且每种维度都希望能够独立扩展
            4. 对于使用多层继承会造成类数量的过多的系统

        6. 编写步骤：

            1. 编写抽象类，通过构造方法注入具体实现接口的成员变量，并且在抽象类中定义抽象方法
            2. 编写具体实现接口，定义（需要独立变化与扩展的）业务方法
            3. 编写具体实现接口的实现类，实现上述的业务方法
            4. 编写细化（扩展）抽象子类，实现抽象类中定义的抽象方法。此时，可以调用父类中具体实现接口的成员变量中的方法，完成对不同维度功能的组合
            5. 编写客户端，定义抽象引用和具体实现接口引用，创建不同的抽象细化类与具体接口实现类，将具体接口实现类Set到抽象细化类中，便可以组合出具有不同功能的对象

    - #### 装饰模式

        1. 优点：

            1. 扩展对象的功能比继承更加灵活，减少了继承层次，不会导致类爆炸
            2. 能够动态扩展对象的功能，实现不同行为（例如：读取配置文件，选择不同的具体装饰类）
            3. 对透明装饰模式，可以多次装饰某个对象，排列组合得到不同行为与功能的对象
            4. 具体组件类与具体装饰类互相独立，符合开闭原则

        2. 缺点：

            1. 因为不同的修饰方式可以产生功能不同的对象，所以会导致系统存在很多小对象，它们的区别仅仅是组合、连接的方式不同，不是类或者属性的不同，小对象过多会影响系统性能
            2. 对于被多次装饰的对象，不利于排查错误

        3. 作用：动态的给某个对象添加额外的职责，提供比继承更加灵活的扩展方式

        4. 分类：

            1. 透明装饰模式：
                1. 客户端全部使用抽象组件接收实例化的部分
                2. 可以对组件多次装饰（因为都是抽象组件的子类，并且通过构造方法实例化抽象组件成员变量）
                3. 客户端没办法调用具体装饰器中新增的方法（因为抽象组件中没有定义这些方法）
            2. 半透明装饰模式：
                1. 客户端可以使用抽象组件接收具体组件，但是只能用具体装饰器引用接收具体装饰器的实例，从而能够调用具体装饰器中的新增方法
                2. 不能多次装饰具体组件，只能装饰一次

        5. 类图：图中为透明装饰模式，若为半透明装饰模式，则具体组件只能被装饰一次，并且可以单独调用被添加（用于装饰对象）的方法

           ![image-20200708221913631](/assets/image-20200708221913631.png)

        6. 使用场景：

            1. 不影响其他对象实例，只想对某个对象实例动态、透明的添加职责
            2. 无法使用继承或继承不利于系统维护与扩展时，可以通过装饰模式来扩展功能（例如：Java中的final类、继承层次过多等）

        7. 编写方法：

            1. 编写抽象组件类，定义抽象方法（需要被修饰、增强的方法）
            2. 编写具体组件类，继承抽象组件类
            3. 编写装饰类，继承抽象组件类，在类中添加抽象组件的成员变量，通过构造器实例化抽象组件的成员变量
            4. 在装饰类中，重写抽象方法时，调用成员变量的抽象方法
            5. 编写具体装饰类，继承装饰类，构造方法调用中调用装饰类的构造方法，传入抽象组件对象
            6. 在具体装饰类中，重写抽象方法时，**调用成员变量的抽象方法（原本的业务方法），调用自身新增的业务方法**
            7. 编写客户端类，创建具体组件对象，传入具体装饰对象的构造方法中，
                1. 若为透明装饰模式，则可以都用抽象组件引用接收对象并使用，并且可以多次装饰，没有办法调用被装饰后新增的业务方法
                2. 若为半透明装饰模式，则定义具体组件可以用抽象组件的引用接收，被装饰的对象只能用具体装饰器接收，此时可以调用具体装饰对象的新增业务方法

    - #### 组合模式

        1. 优点：

            1. 能够清楚地定义层次关系，客户端可以忽略层次的不同进行操作
            2. 透明组合模式下，由于客户端能够一致的使用叶子构件和容器构件的方法，所以能简化调用代码
            3. 添加叶子构件或者容器构件都十分方便，无需改动现有代码，符合开闭原则
            4. 不仅对树形结构的控制简单，而且能够通过叶子构件与容器构件递归组合，实现复杂的树形结构

        2. 缺点：

            1. 添加新的构件类型，容易产生过多的类
            2. 如果希望某个容器下只允许某种叶子构件，需要编写代码约束，十分复杂（不然客户端给A容器添加C容器的C叶子节点，而本来A容器应该添加A叶子节点）

        3. 作用：组合多种对象，形成树形结构，表示部分-整体的层次结构。组合模式能统一操作叶子节点与父节点，无需关心它们的区别

        4. 分类：

            1. 透明组合模式：调用叶子构件与容器构件都一样，但是调用叶子构件会产生异常，没有进行处理会出错
            2. 安全组合模式：抽象构件中不提供操作子节点的方式，这样客户端无法统一对叶子构件和容器构件编程，不会出现抛不支持操作异常的情况

        5. 类图：

            - AbstracComponent：抽象构件，可以是抽象类或者接口，为叶子节点（叶子构件）与父节点（容器构件）声明通用操作的接口
            - Composite：容器构件，实现抽象构件中的接口，使用集合存储它所管理的叶子节点列表，并且可以递归调用子节点的方法，直到调用时遇到叶子节点为止
            - Leaf：叶子构件，它没有子节点，实现抽象构件中的部分接口，如果调用了它未实现的操作方法，则可以抛出异常（例如：调用叶子节点增加子节点的方法，可以抛出不支持该操作的异常）

           ![image-20200711220850156](/assets/image-20200711220850156.png)

        6. 使用场景：

            1. 具有部分与整体的层次结构，并且希望客户端统一管理部分与整体
            2. 希望在面向对象语言中处理树形结构，并且节点具有相似的方法
            3. 系统可以分离出叶子构件与容器构件，并且它们的类型数量不确定，希望随时扩充新类型(Swing包中的Panel(容器)和Button(叶子)等GUI编程)

        7. 编写方法：

            1. 编写抽象构件类：定义通用的子节点管理抽象方法(增删改查子节点)，定义需要实现的抽象业务方法
            2. 编写容器构件类：继承或者实现抽象构件中的方法，编写一个抽象构件集合，用于存储当前容器所管理的子构件列表
            3. 编写叶子构件类：继承或实现抽象构件中的方法
            4. 编写客户端，定义抽象构件的引用，实例化容器构件与叶子构件，将叶子构件添加到容器构件中，再调用容器构件的业务方法

    - #### 外观模式

        1. 优点：

            1. 子系统内部的变化不影响外观对象
            2. 客户端只需要依赖外观对象，不需要关联子系统的各种对象，降低了耦合，让子系统更加容易使用
            3. 子系统内部的变化不影响客户端对其使用

        2. 缺点：

            1. 客户端可能绕过门面类直接访问子系统，想要避免这种情况会减低子系统的灵活性与可变性
            2. 如果门面类设计有缺陷，后期新增子系统或者新增门面功能会导致门面类代码变动，不符合开闭原则

        3. 作用：作为子系统接口调用的统一入口，方便使用子系统

        4. 类图：

           ![image-20200714075134290](/assets/image-20200714075134290.png)

        5. 使用场景：

            1. 为客户端提供多种复杂子系统的统一API调用入口
            2. 客户端与子系统的耦合很强，通过引入外观类进行解耦
            3. 在多层结构中，通过外观类定义每层的入口，由外观类进行层与层之间的通信，降低了层之间的耦合度

        6. 编写方法：

            1. 编写抽象外观类，定义通用的抽象方法
            2. 编写子系统类（单例类、工厂类等），实现该子系统负责模块的方法
            3. 编写具体外观类继承抽象外观类，定义具体外观类中需要用到的子系统成员变量，调用并且组合子系统中的模块方法实现父类的抽象方法
            4. 创建客户端类，定义抽象门面类的引用，实例化具体门面类，调用通用的抽象方法

    - #### 享元模式

        1. 优点：
            1. 重复利用（相同或相似的）细粒度对象，节省系统资源
            2. 区分了对象的外部状态与内部状态，它们相互独立，使得具有不同外部状态的对象可以共享相同的内部状态对象（例如：棋子的位置对象[外部状态]与黑色或白色棋子对象[内部状态]，可以通过设置不同的位置坐标，传入黑棋或者白棋，黑棋或白棋对象则只会产生一个）

        2. 缺点：

            1. 分离了内部状态与外部状态，使得对象变得复杂，对对象的操作也会复杂
            2. 由于分离了内部与外部状态，那么读取这个对象对应的外部状态需要耗费更长的时间

        3. 作用：运用共享技术复用大量细粒度的对象

        4. 类图：使用单例模式创建共享的享元对象以及享元工厂；使用组合模式组合共享的享元对象与不共享的享元对象；使用享元模式对共享的对象进行缓存，而不是重复创建（此图为复合享元模式的类图）

           ![image-20200719122349688](/assets/image-20200719122349688.png)

        5. 分类

            1. 单纯享元模式：只存在可以共享的享元类，没有不可共享的享元类，即只有上图的ConcreteFlyweight类、AbstractFlyweight类、FlyweightFactory类
            2. 复合享元模式：使用组合模式组合了不可共享的类

        6. 使用场景：

            1. 系统中存在大量相同或者相似的对象
            2. 某种对象的大部分状态可以分为不变与变化的，将变化的状态封装成不共享的对象，不变的状态进行缓存
            3. 由于使用缓存池缓存享元对象，会耗费系统资源，所以享元对象应该被频繁使用，避免浪费资源

    - #### 代理模式

        1. 优点：

            1. 通过代理对象协调调用者与被调用者，降低了它们之间的耦合度
            2. 客户端使用代理对象进行编程，所以修改被代理对象的代码时，客户端无需修改代码，符合开闭原则
            3. 使用远程代理时，可以将运算复杂的业务放置在高性能服务器中，提升了系统整体的运行效率
            4. 使用虚拟代理时，可以懒加载某些需要庞大性能的对象，节省了系统资源
            5. 使用缓冲代理时，可以对运算结果进行临时缓存，共享给后续运算步骤，优化了系统性能
            6. 使用保护代理时，可以控制对象的访问权限，给不同的客户端分配不同的使用权限

        2. 缺点：

            1. 由于多了代理层，可能会造成业务处理速度降低（例如：保护代理，需要进行权限检查，而权限检查需要耗费系统资源）
            2. 某些代理模式的实现方式十分复杂（例如：Java中的RMI（远程代理），需要序列化对象，反序列化对象等一系列操作）

        3. 作用：提供某个对象的代理对象，由代理对象来控制对原来对象的访问

        4. 分类：

            1. 远程代理：使得客户端能使用远程服务器中的方法
            2. 虚拟代理：对加载时间长的对象，先使用“虚假”的代理对象来代表真实对象，等真实对象加载完毕后，虚拟代理将请求转发给真实对象
            3. **静态代理**：代理类和被代理类都必须继承或实现相同的父类或接口，代理类持有被代理类的成员变量，并且重写父类方法，调用被代理类中相同的方法（这样会导致代理类的数量过多）
            4. **JDK动态代理**：能够在系统运行时，根据需要动态的创建代理类，使得同一个代理类能代理多个不同的被代理类，常用于事务管理、AOP编程等（被代理的对象必须实现或继承它原本的父类或接口）
            5. **CGLIB(Code Generation Library)动态代理**：与JDK动态代理相比，被代理的类也不需要实现接口或者继承父类
            6. 保护代理：对于某些敏感的对象，在调用前，代理对象会检查客户是否具有权限，没有权限则不允许调用
            7. 缓冲代理：对于计算量较大的对象，通过在客户端或者服务端创建缓冲代理对象，避免每次调用都进行重复计算
            8. 智能引用代理：代理对象内部计数器计算调用次数，当没有使用者调用时，则该自动释放该代理对象

        5. 类图：下图为静态代理模式的类图，代理对象与被代理对象都必须实现相同的接口，代理对象可以在调用被代理对象方法的时候，进行一些额外的操作

           ![image-20200726114532383](/assets/image-20200726114532383.png)

        6. 使用场景：

            1.  客户都安需要访问远程服务器中的对象，可以使用远程代理
            2. 可以通过虚拟代理缩短系统的启动时间
            3. 对频繁访问的计算结果，使用缓冲代理进行缓存
            4. 需要对调用方进行权限控制，可以使用保护代理
            5. 需要为某个对象的引用提供额外功能时，可以使用智能引用代理（例如：某个对象的引用次数为0，则可以释放该对象）

3. ### 行为型：关注方法层面的调用

    - #### 模板方法模式

        1. 优点：

            1. 抽象出公共步骤，复用了代码
            2. 子类实现具体的细节，便于替换与扩展算法实现
            3. 类的行为由父类控制，子类负责实现

        2. 缺点：

            1. 修改骨架十分困难
            2. 会导致类数量过多

        3. 作用：定义一系列的算法步骤，将实现延迟到子类，使得子类能够不改变算法的整体结构，重新定义某些特定的算法步骤

        4. 类图：子类通过重写钩子方法可以决定是否执行某些算法步骤

           ![image-20200729104917807](/assets/image-20200729104917807.png)

        5. 使用场景：

            1. 需要控制子类的扩展，以符合算法规则
            2. 不同的类中，存在相同的业务流程，出现大量重复代码

    - #### 命令模式

        1. 优点：

            1. 实现请求的调用者与请求的执行者解耦
            2. 可以实现不同的命令子类，扩展性好

        2. 缺点：会导致类的数量过多

        3. 作用：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。

        4. 类图：通过栈保存命令调用的历史，以此达到撤销命令，还可以结合组合模式执行宏命令（一系列的命令批量执行）

           ![image-20200730160633409](/assets/image-20200730160633409.png)

        5. 使用场景：

            1. 需要撤销多次处理
            2. 实现原子事务（出现异常需要回滚）
            3. 命令含义稳定，并且希望解耦命令的调用者与执行者

    - #### 访问者模式

        1. 优点：

            1. 增加新的访问者（访问操作）十分方便，满足开闭原则
            2. 将访问的行为内聚到访问者对象中，让类的职责更清晰，使得复杂对象可供多个不同的访问者访问
            3. 不修改结构层次关系，却能对层次添加操作

        2. 缺点：

            1. 新增具体元素类，不符合开闭原则，每个访问者对象都需要进行修改
            2. 访问者访问的元素必须暴露某些内部操作、状态供其使用，破坏了对象的封装性

        3. 作用：对操作复杂对象中的不同部分，在改变原有类的前提下，提供不同的操作方法

        4. 类图：

           ![image-20200802153201574](/assets/image-20200802153201574.png)

        5. 使用场景：

            1. 一个复杂对象中，存在多种不同的对象，希望根据不同的访问者对这些对象进行不同的操作
            2. 复杂对象的结构稳定，并且需要经常为其添加新的操作方式
            3. 希望对复杂对象的访问操作分离，避免大量的操作方式让复杂对象过于臃肿

    - #### 迭代器模式

        1. 优点：

            1. 将遍历对象与存储对象分离，使得遍历时无需知道其内部结构，降低了耦合性
            2. 通过实现不同的迭代器可以替换遍历算法，并且为不同对象的遍历提供了统一的编程方式
            3. 对某个聚合对象添加新的遍历算法，只需要实现新的迭代器，符合开闭原则

        2. 缺点：

            1. 实现不同的遍历器类会导致类数量过多(可以通过内部类实现解决)
            2. 对遍历器接口的设计要求很高，若要修改遍历接口，则不符合开闭原则
            3. 遍历时，不能修改被遍历的集合，否则会遍历出错

        3. 作用：提供一种方法访问聚合对象，而无需知道其内部结构

        4. 类图：使用内部类来实现具体迭代器类

           ![image-20200804084117099](/assets/image-20200804084117099.png)

        5. 使用场景：

            1. 访问某个对象的元素而无需暴露其内部结构
            2. 需要为某个对象提供多种遍历方式
            3. 为不同对象的遍历方式提供统一的遍历操作接口，使得客户端能够统一遍历方式

    - #### 观察者模式

        1. 优点：

            1. 将表示层与数据层分离，使得不同层次的对象都可以充当观察者
            2. 观察者与被观察者通过抽象耦合，它们无需知道对方具体的实现细节，便可以与对方进行通信
            3. 简化了一对多的广播通信等系统的设计难度
            4. 增加新的具体观察者符合开闭原则；当观察者与被观察者没有关联时，新增被观察者也十分方便

        2. 缺点：

            1. 观察者过多，会导致推送更新的时间过长
            2. 若观察者和被观察的对象之间存在循环依赖，则观察者模式会触发死循环
            3. 观察者无法知道是什么原因导致被观察的目标发生变化

        3. 作用：定义对象之间的一对多关系，使得一个对象的状态发生改变，它的观察者都能收到通知并且更新自身持有的信息

        4. 类图：

           ![image-20200804221620143](/assets/image-20200804221620143.png)

        5. 使用场景：

            1. 存在两个抽象的模型，且一方依赖于另外一方，则可使用观察者模式在抽象层进行关联，使得它们能够独立的改变与复用
            2. 一个对象的改变需要通知其他对象也发生改变，并且不知道这些对象的类型与数量
            3. 可以使用观察者模式形成触发链

    - #### 中介者模式

        1. 优点：

            1. 将对象间多对多的关联关系转换成一对多的关联关系，简化了编程的复杂度，更容易维护与理解、扩展
            2. 解耦具体同事类之间的关联关系，使得它们能够相互独立变化，符合开闭原则
            3. 具体同事类可以被子中介者类复用，降低了类的数量

        2. 缺点：中介者类中包含大量同事类的交互逻辑，难以维护，容易出错

        3. 作用：用一个中介对象封装一系列对象的交互，使这些对象无需显示引用对方，从而降低它们的耦合，让它们能独立变化

        4. 类图：同事类One和Two，通过中介者类进行通信。中介者根据具体的同事类，决定执行如何调用其他同事类

           ![Package intermediary](/assets/Package intermediary.png)

        5. 使用场景：

            1. 系统中的对象存在复杂的引用关系，系统结构混乱并且难以理解
            2. 某个对象引用了许多对象，并且与这些对象进行交互，并且希望能复用它
            3. 希望通过一个中间类封装多个类中的行为，又不希望创建过多的中间类

    - #### 备忘录模式（对象行为模式）

        1. 优点：

            1. 提供对象状态恢复的机制，可用于对象变更成新状态遇到问题时，恢复老状态
            2. 通过栈等其他数据结构存储实现，可进行多次撤销操作，即使执行时状态产生了分支，也能回退

        2. 缺点：当状态对象过于复杂时，使用备忘录对象保存状态会造成过多的内存开销（需要只记录每次修改变动的部分解决此问题，但其实现将十分困难）

        3. 作用：不破坏对象内部封装的前提下，保存其内部状态到其他对象中，当需要恢复状态的时候进行恢复

        4. 类图：通过内部类和栈实现多步回退机制

           ![image-20200806203905578](/assets/image-20200806203905578.png)

        5. 使用场景：

            1. 需要保存某一时刻某个对象的所有状态，以便于后续进行恢复
            2. 希望将状态对象的变更历史保存到它自己当中，不希望其他对象修改它的变更历史


- #### 解释器模式（类行为模式）

    1. 优点：

        1. 能够轻松实现简单的文法规则，新增文法规则只需要添加新的实现类，符合开闭原则
        2. 具体节点类之间存在相似的结构，可以使用工具自动生成相关代码

    2. 缺点：

        1. 复杂的文法类的数量会过多
        2. 执行效率不高（因为解释复杂句子时，存在大量递归与循环调用，并且难以理解与调试）

    3. 作用：定义一种语言文法，编写对应的解释器对其进行翻译，执行其具体含义

    4. 类图：定义抽象节点（BaseNode）、中间语法节点（ExpressionNode、CommandNode）、语法叶子节点（NonLoopNode、LoopNode），其中表达式节点由多个命令节点组成，命令节点由多个循环或者不循环叶子节点组成，最后通过上下文（Context类）携带的句子信息，使用ExpressionNode节点进行翻译与执行命令

       ![Package interpreter](/assets/Package interpreter.png)

    5. 使用场景：

        1. 执行效率要求不高，需要进行简单的文法转换
        2. 可以用简单文法描述的重复问题（例如：二维平面的移动，确定方向与距离，多次执行命令，便可以到达任何位置）
- #### 状态模式（对象行为模式）

    1. 优点：

        1. 将状态代码与状态对象解耦，便于集中管理控制状态的相关代码
        2. 持有不同的状态对象，可以具有不同的功能实现方式
        3. 可以通过环境对象共享状态对象，减少所需的具体状态类

    2. 缺点：

        1. 由于分离了环境对象与其状态，当状态的种类较多时，会产生较多的具体状态类
        2. 增加新状态需要修改那些负责转换状态的类，不符合开闭原则
        3. 分离状态代码会导致代码的设计难度提升

    3. 作用：使得对象的内部状态发生改变，其行为也随之改变

    4. 类图：可通过状态类控制状态转换，也可以通过上下文类自身进行状态的控制，还可以通过静态状态成员变量在上下文对象间进行状态共享

       ![Package state](/assets/Package state.png)

    5. 使用场景：

        1. 对象的行为依赖自身的属性值
        2. 模块中存在大量处理、维护状态的语句
- #### 策略模式（对象行为模式）

    1. 优点：
        1. 完全符合开闭原则，可以不修改原有的代码进行新增、修改算法
        2. 通过抽象策略类可以复用公共的算法代码，并且具体策略也可以被其他上下文类复用
        3. 允许在运行时切换具体的算法实现，并且支持每种不同的算法独立扩展与修改
        4. 能够避免大量分支语句块的出现
2. 缺点：
    1. 客户端需要理解每种不同的算法，当算法种类过多时，学习成本较大
    2. 任何算法的变化都会新增具体策略类，会造成具体策略类过多
    3. 无法混用多种策略（比如使用A策略类的前三步，再用B策略类的后三步完成业务处理）

3. 作用：定义一系列的算法，由具体子类实现不同的算法，将这些算法封装起来，使得它们可以相互替换

4. 类图：

   ![image-20200811084646661](/assets/image-20200811084646661.png)

5. 使用场景：
    1. 模块的运行需要动态切换成某种不同的算法逻辑
    2. 业务逻辑存在大量分支语句，存在多重条件选择语句（例如 A && B && C），可以通过策略分发的方式消除
    3. 不希望客户端知道算法的具体实现逻辑

- #### 责任链（职责链）模式（对象行为模式）

    1. 分类:

        - 完全（纯职责）职责模式：
            1. 请求只能被职责链中的某一个环节处理，不能继续转发至其他节点
            2. 不能出现请求没有节点处理的情况
        - 不完全（不纯）职责模式：
            1. 请求被某个节点处理后，可以继续传递给后续节点进行处理
            2. 可以出现请求没有被任何节点处理的情况

    2. 优点：

        1. 请求对象与处理对象进行解耦，职责链由客户端创建，降低系统的耦合度
        2. 每一位请求处理者只需要维持后一位处理者的引用，而无需知晓全部处理者
        3. 可以在运行时修改职责链，从而动态改变处理流程
        4. 新增处理节点时，符合开闭原则

    3. 缺点：

        1. 请求可能会因为职责链的配置错误而无法正确处理
        2. 职责链过长，处理性能会受影响，并且调试难度增加

    4. 作用：将请求发送者与请求处理者分离（由多个处理对象组成一条处理链，请求沿着链条传递，直到有对象能对请求进行处理）

    5. 类图：

       ![Package chain](/assets/Package chain.png)

    6. 使用场景：

        1. 多个对象都能处理一个请求，并且需要运行时才确定使用哪个对象进行处理，客户端不关心具体处理请求的对象
        2. 想要动态改变请求处理者的先后顺序、处理者的数量等职责链相关的属性